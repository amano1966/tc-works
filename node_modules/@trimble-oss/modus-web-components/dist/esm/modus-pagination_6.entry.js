import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-612c46d2.js';
import { I as IconChevronLeft } from './IconChevronLeft-dfd06381.js';
import { I as IconChevronRight } from './IconChevronRight-5734b74b.js';
import { f as KEYBOARD_ENTER, j as KEYBOARD_SPACE, g as KEYBOARD_ESCAPE, r as COLUMN_DEF_CELL_EDITOR_ARGS_KEY, b as COLUMN_DEF_DATATYPE_KEY, s as CELL_EDIT_TYPE_TEXT, A as ALLOWED_CELL_EDIT_TYPES, t as COLUMN_DEF_DATATYPE_BADGE, c as COLUMN_DEF_DATATYPE_INTEGER, u as COLUMN_DEF_DATATYPE_CUSTOM, v as COLUMN_DEF_DATATYPE_LINK, w as COLUMN_DEF_CELL_EDITOR_TYPE_KEY } from './modus-table.constants-3cf5de92.js';
import { N as NavigateTableCells } from './table-cell-navigation.utility-59aae646.js';
import { c as createPopper } from './popper-0fbeff6d.js';

var PaginationDirection;
(function (PaginationDirection) {
    PaginationDirection["Previous"] = "Previous";
    PaginationDirection["Next"] = "Next";
})(PaginationDirection || (PaginationDirection = {}));

const modusPaginationCss = "nav{align-items:center;background-color:transparent;border-radius:0.25rem;color:var(--modus-pagination-color, #252a2e);display:inline-flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";justify-content:center;width:100%}nav svg path{fill:var(--modus-pagination-chevron-color, #6a6e79)}nav ul{align-items:center;display:flex;flex-direction:row;justify-content:center;padding:0}nav ul li{list-style-type:none;user-select:none}nav ul li button{align-items:center;background-color:transparent;border:unset;border-radius:0.25rem;color:var(--modus-pagination-color, #252a2e);display:flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";justify-content:center}nav ul li button.active{background-color:var(--modus-pagination-active-bg, #dcedf9);color:var(--modus-pagination-active-color, #217cbb);outline:1px solid transparent}nav ul li button.disabled{opacity:0.3}nav ul li button.hoverable{cursor:pointer}nav ul li button.hoverable:not(.active):hover{background-color:var(--modus-pagination-hover-bg, #e0e1e9)}nav.small{height:1.5rem}nav.small ul li button{font-size:0.75rem;height:1.5rem;padding:0 0.5rem}nav.small ul li button[aria-label=Next],nav.small ul li button[aria-label=Previous]{padding-left:0.25rem;padding-right:0.25rem}nav.medium{height:2rem}nav.medium ul li button{font-size:0.875rem;height:2rem;padding:0 0.75rem}nav.medium ul li button[aria-label=Next],nav.medium ul li button[aria-label=Previous]{padding-left:0.375rem;padding-right:0.375rem}nav.large{height:3rem}nav.large ul li button{font-size:1.25rem;height:3rem;padding:0 1.125rem}nav.large ul li button[aria-label=Next],nav.large ul li button[aria-label=Previous]{padding-left:0.75rem;padding-right:0.75rem}";
const ModusPaginationStyle0 = modusPaginationCss;

const ModusPagination = class {
    activePageWatch(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.pageChange.emit(newValue);
        }
    }
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.pageChange = createEvent(this, "pageChange", 7);
        this.chevronSizeBySize = new Map([
            ['small', '16'],
            ['medium', '20'],
            ['large', '24'],
        ]);
        this.classBySize = new Map([
            ['small', 'small'],
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.ariaLabel = undefined;
        this.activePage = 1;
        this.maxPage = undefined;
        this.minPage = undefined;
        this.prevPageButtonText = undefined;
        this.nextPageButtonText = undefined;
        this.size = 'medium';
        this.pages = undefined;
        this.setPages();
    }
    componentWillRender() {
        if (this.activePage === undefined || isNaN(this.activePage)) {
            this.activePage = 1;
        }
        this.setPages();
    }
    setPages() {
        const pages = [];
        const ellipsis = '...';
        // Always show the first page.
        this.maxPage > 1 && pages.push(this.minPage);
        if (this.maxPage - this.minPage < 7) {
            // No need for ellipsis for 7 pages - push all of them.
            for (let i = this.minPage + 1; i < this.maxPage; i++) {
                pages.push(i);
            }
        }
        else {
            if (this.activePage - this.minPage < 4) {
                // One of the first 4 pages is active.
                [1, 2, 3, 4].map((val) => pages.push(this.minPage + val));
                pages.push(ellipsis);
            }
            else if (this.maxPage - this.activePage < 4) {
                // One of the last 4 pages is active.
                pages.push(ellipsis);
                [4, 3, 2, 1].map((val) => pages.push(this.maxPage - val));
            }
            else {
                // The active page is somewhere in the middle.
                pages.push(ellipsis);
                [-1, 0, 1].map((val) => pages.push(this.activePage + val));
                pages.push(ellipsis);
            }
        }
        // Always show the last page.
        pages.push(this.maxPage);
        this.pages = pages;
    }
    handleChevronClick(direction) {
        if (direction === PaginationDirection.Previous && this.activePage !== this.minPage) {
            this.activePage--;
        }
        else if (direction === PaginationDirection.Next && this.activePage !== this.maxPage) {
            this.activePage++;
        }
    }
    handleChevronKeydown(event, direction) {
        if (event.key.toLowerCase() === 'enter') {
            this.handleChevronClick(direction);
            event.preventDefault();
        }
    }
    handlePageKeydown(event, page) {
        if (event.key.toLowerCase() === 'enter') {
            this.handlePageClick(page);
            event.preventDefault();
        }
    }
    handlePageClick(page) {
        if (!isNaN(page)) {
            this.activePage = page;
        }
    }
    renderPreviousPageControl() {
        return (this.maxPage - this.minPage >= 7 && (h("li", null, h("button", { "aria-label": "Previous", class: `${this.activePage != this.minPage ? 'hoverable' : 'disabled'}`, disabled: this.activePage === this.minPage, onClick: () => this.handleChevronClick(PaginationDirection.Previous), onKeyDown: (event) => this.handleChevronKeydown(event, PaginationDirection.Previous) }, this.prevPageButtonText ? (h("span", { "data-test-id": "prev-button-text" }, this.prevPageButtonText)) : (h(IconChevronLeft, { size: this.chevronSizeBySize.get(this.size) }))))));
    }
    renderNextPageControl() {
        return (this.maxPage - this.minPage >= 7 && (h("li", null, h("button", { "aria-label": "Next", class: `${this.activePage != this.maxPage ? 'hoverable' : 'disabled'}`, disabled: this.activePage === this.maxPage, onClick: () => this.handleChevronClick(PaginationDirection.Next), onKeyDown: (event) => this.handleChevronKeydown(event, PaginationDirection.Next) }, this.nextPageButtonText ? (h("span", { "data-test-id": "next-button-text" }, this.nextPageButtonText)) : (h(IconChevronRight, { size: this.chevronSizeBySize.get(this.size) }))))));
    }
    renderPageNumbers() {
        return this.pages.map((page) => {
            const isCurrentPage = page === this.activePage;
            if (page === '...') {
                return (h("li", null, h("button", { class: `${!isNaN(+page) ? 'hoverable' : ''}`, tabIndex: -1 }, page)));
            }
            return (h("li", null, h("button", { "aria-current": isCurrentPage ? 'page' : null, class: `${page === this.activePage ? 'active' : ''} ${!isNaN(+page) ? 'hoverable' : ''}`, onClick: () => this.handlePageClick(+page), onKeyDown: (event) => this.handlePageKeydown(event, +page) }, page)));
        });
    }
    render() {
        return (h("nav", { key: '3daf4148138b3f2532d1fc5398a5166ba6d0af23', "aria-label": this.ariaLabel || undefined, class: `${this.classBySize.get(this.size)}` }, h("ul", { key: 'd129a1b45d58ab78102a0a55143c3fd22cae7484' }, this.renderPreviousPageControl(), this.renderPageNumbers(), this.renderNextPageControl())));
    }
    static get watchers() { return {
        "activePage": ["activePageWatch"]
    }; }
};
ModusPagination.style = ModusPaginationStyle0;

// Code taken from - https://github.com/TanStack/table/blob/main/packages/react-table/src/index.tsx
/**
 * Cell formatter enables formatting of a cell value.
 */
function CellFormatter(Comp, props) {
    return !Comp ? null : isFunction(Comp) ? h(Comp, Object.assign({}, props)) : Comp;
}
/**
 * Checks if the input for cell formatter is a function object.
 */
function isFunction(component) {
    return isClassComponent(component) || typeof component === 'function';
}
function isClassComponent(component) {
    return (typeof component === 'function' &&
        (() => {
            const proto = Object.getPrototypeOf(component);
            return proto.prototype && proto.prototype.isFunctionalComponent;
        })());
}

const ModusTableCellLinkElement = ({ link, onLinkClick }) => {
    function handleLinkKeyDown(e) {
        const key = e.key.toLowerCase();
        if (key === KEYBOARD_ENTER || key === KEYBOARD_SPACE) {
            onLinkClick(link);
            e.stopImmediatePropagation();
        }
    }
    return (h("div", { class: "cell-link", tabIndex: 0, onClick: () => onLinkClick(link), onKeyDown: handleLinkKeyDown }, link.display));
};

const ModusTableCellBadgeElement = ({ badge, onBadgeClick }) => {
    function handleBadgeKeyDown(e) {
        const key = e.key.toLowerCase();
        if (key === KEYBOARD_ENTER || key === KEYBOARD_SPACE) {
            onBadgeClick(badge);
            e.stopImmediatePropagation();
        }
    }
    return (h("div", { class: "cell-badge", onClick: () => onBadgeClick(badge), onKeyDown: () => handleBadgeKeyDown },
        h("modus-badge", { tabIndex: 0, color: badge.color, size: badge.size, type: badge.type, ariaLabel: badge === null || badge === void 0 ? void 0 : badge.ariaLabel }, badge.text)));
};

// eslint-disable-next-line
const IconChevronDownThick = (props) => {
    var _a, _b, _c;
    return (h("svg", { class: `icon-chevron-down-thick ${props.pressed ? 'pressed' : ''}`, fill: (_a = props.color) !== null && _a !== void 0 ? _a : 'currentColor', height: (_b = props.size) !== null && _b !== void 0 ? _b : 16, width: (_c = props.size) !== null && _c !== void 0 ? _c : 16, onClick: props.onClick, viewBox: "0 0 24 24" },
        h("path", { d: "M15.88 9.29 12 13.17 8.12 9.29a.996.996 0 1 0-1.41 1.41l4.59 4.59c.39.39 1.02.39 1.41 0l4.59-4.59a.996.996 0 0 0 0-1.41c-.39-.38-1.03-.39-1.42 0z" })));
};

// eslint-disable-next-line
const IconChevronUpThick = (props) => {
    var _a, _b, _c;
    return (h("svg", { class: `icon-chevron-up-thick ${props.pressed ? 'pressed' : ''}`, fill: (_a = props.color) !== null && _a !== void 0 ? _a : 'currentColor', height: (_b = props.size) !== null && _b !== void 0 ? _b : 16, width: (_c = props.size) !== null && _c !== void 0 ? _c : 16, onClick: props.onClick, viewBox: "0 0 24 24" },
        h("path", { d: "M11.29 8.71 6.7 13.3a.996.996 0 1 0 1.41 1.41L12 10.83l3.88 3.88a.996.996 0 1 0 1.41-1.41L12.7 8.71a.996.996 0 0 0-1.41 0z" })));
};

const ModusTableCellExpandIcons = ({ row }) => {
    let expandEl;
    return (h("span", { class: "expand-icon-container", ref: (ref) => (expandEl = ref), style: { paddingLeft: `${row.depth * 2}rem` }, onClick: (e) => {
            row.getToggleExpandedHandler()();
            e.stopImmediatePropagation();
        } }, row.getCanExpand() && (h("span", { class: "expand-icon", tabIndex: 0, onKeyDown: (event) => {
            if (event.key.toLowerCase() === KEYBOARD_ENTER || event.key.toLowerCase() === KEYBOARD_SPACE) {
                expandEl.click();
                event.stopImmediatePropagation();
            }
        } }, row.getIsExpanded() ? h(IconChevronUpThick, { size: '24' }) : h(IconChevronDownThick, { size: '24' })))));
};

const ModusTableCustomCellElement = ({ customElement }) => {
    return h("div", { class: "cell-custom" },
        " ",
        h("flex-renderer", { content: customElement.getValue().toString() }));
};

const ModusTableCellMain = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.cellInputValueChange = createEvent(this, "cellInputValueChange", 7);
        this.onCellClick = (e) => this.handleCellClick(e);
        this.onCellKeyDown = (e) => this.handleCellKeydown(e);
        this.onCellBlur = (e) => this.handleCellBlur(e);
        this.cellEditableKey = 'cellEditable';
        this.accessorKey = 'accessorKey';
        this.isCellEditable = () => {
            var _a;
            const editable = this.cell.column.columnDef[this.cellEditableKey];
            const isDisabledFn = (_a = this.getEditorArgs()) === null || _a === void 0 ? void 0 : _a.isCellDisabled;
            const isDisabled = typeof isDisabledFn === 'function' ? isDisabledFn(this.cell.row.original) : false;
            return editable && !isDisabled;
        };
        this.handleCellClick = (event) => {
            if (event.defaultPrevented)
                return;
            if (this.isCellEditable()) {
                this.editMode = true;
            }
        };
        this.handleCellBlur = (event) => {
            if (!this.el.contains(event.relatedTarget)) {
                this.editMode = false;
            }
        };
        this.handleCellKeydown = (event) => {
            if (event.defaultPrevented)
                return;
            if (this.isCellEditable()) {
                this.editMode = true;
                event.stopPropagation();
            }
            else {
                NavigateTableCells({
                    eventKey: event.key,
                    cellElement: this.cellEl,
                });
            }
        };
        this.handleCellEditorOnInputChange = (newValue, oldValue) => {
            this.cellInputValueChange.emit({
                row: this.cell.row,
                accessorKey: this.cell.column.columnDef[this.accessorKey],
                newValue,
                oldValue,
            });
        };
        this.handleCellEditorKeyDown = (event, newValue, oldValue) => {
            var _a;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (key === KEYBOARD_ENTER) {
                this.handleCellEditorValueChange(newValue, oldValue);
                NavigateTableCells({
                    eventKey: KEYBOARD_ENTER,
                    cellElement: this.cellEl,
                });
            }
            else if (key === KEYBOARD_ESCAPE) {
                this.editMode = false;
                this.cellEl.focus();
                this.destroyErrorTooltip();
            }
            else
                return;
            event.stopPropagation();
        };
        this.cell = undefined;
        this.context = undefined;
        this.hasRowsExpandable = undefined;
        this.valueChange = undefined;
        this.errorMessage = undefined;
        this.editMode = undefined;
    }
    onEditModeChange(newValue) {
        if (newValue) {
            this.cellEl.classList.add('edit-mode');
            this.createErrorTooltip(); // Create tooltip when entering edit mode
            if (this.errorMessage)
                this.showErrorTooltip();
        }
        else {
            this.cellEl.classList.remove('edit-mode');
            this.destroyErrorTooltip(); // Destroy tooltip when exiting edit mode
        }
    }
    onContextChange() {
        this.updateErrorState();
    }
    connectedCallback() {
        this.cellEl = this.el.parentElement;
        this.cellEl.addEventListener('click', this.onCellClick);
        this.cellEl.addEventListener('keydown', this.onCellKeyDown);
        this.cellEl.addEventListener('blur', this.onCellBlur);
        this.updateErrorState();
    }
    disconnectedCallback() {
        if (this.cellEl) {
            this.cellEl.removeEventListener('click', this.onCellClick);
            this.cellEl.removeEventListener('keydown', this.onCellKeyDown);
            this.cellEl.removeEventListener('blur', this.onCellBlur);
        }
        this.destroyErrorTooltip();
    }
    updateErrorState() {
        var _a, _b, _c, _d, _e;
        const rowId = (_a = this.cell.row.id) !== null && _a !== void 0 ? _a : this.cell.row.index;
        const accessorKey = this.cell.column.columnDef[this.accessorKey];
        const errorMessage = (_c = (_b = this.context.errors) === null || _b === void 0 ? void 0 : _b[rowId]) === null || _c === void 0 ? void 0 : _c[accessorKey];
        if (errorMessage) {
            this.errorMessage = errorMessage;
            (_d = this.cellEl) === null || _d === void 0 ? void 0 : _d.classList.add('error');
            this.showErrorTooltip();
        }
        else {
            this.errorMessage = '';
            (_e = this.cellEl) === null || _e === void 0 ? void 0 : _e.classList.remove('error');
            this.hideErrorTooltip();
        }
    }
    getEditorType() {
        const editorType = this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_TYPE_KEY];
        const dataType = this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        let editorTypeToReturn = CELL_EDIT_TYPE_TEXT;
        if (!editorType) {
            if (ALLOWED_CELL_EDIT_TYPES.includes(dataType))
                editorTypeToReturn = dataType;
        }
        else {
            editorTypeToReturn = editorType;
        }
        return editorTypeToReturn;
    }
    getEditorArgs() {
        return this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_ARGS_KEY];
    }
    /**
     * Returns whether a cell is editable based on row index and column ID.
     * @param rowIndex The index of the row.
     * @param columnId The ID of the column.
     * @returns Boolean indicating if the cell is editable.
     */
    async handleCellEdit(rowIndex, columnId) {
        const tableInstance = this.cell.getContext().table;
        const row = tableInstance.getRowModel().rows[rowIndex];
        if (!row)
            return;
        const cell = row.getAllCells().find((cell) => cell.column.id === columnId);
        if (!cell)
            return;
        // Focus on the cell element
        const cellElement = this.el.querySelector(`[data-cell-id="${rowIndex}-${columnId}"]`);
        if (cellElement) {
            cellElement.focus();
        }
        this.editMode = true;
    }
    handleCellEditorValueChange(newValue, oldValue) {
        if (this.editMode && newValue !== oldValue && this.valueChange) {
            this.valueChange({
                row: this.cell.row,
                accessorKey: this.cell.column.columnDef[this.accessorKey],
                newValue,
                oldValue,
            });
        }
        this.editMode = false;
    }
    renderCellValue() {
        var _a;
        const { row, getValue } = this.cell;
        const cellValue = getValue();
        const cell = this.cell;
        if (cellValue === null || cellValue === undefined)
            return null;
        const { cellLinkClick, wrapText } = this.context;
        const cellDataType = (_a = cellValue['_type']) !== null && _a !== void 0 ? _a : this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        const wrap = cellDataType === COLUMN_DEF_DATATYPE_BADGE ? false : wrapText;
        const classes = {
            'cell-content': true,
            'truncate-text': !wrap,
            'wrap-text': wrap,
            'text-align-right': cellDataType === COLUMN_DEF_DATATYPE_INTEGER,
        };
        const renderCell = () => {
            if (cellDataType === COLUMN_DEF_DATATYPE_CUSTOM) {
                return h(ModusTableCustomCellElement, { customElement: cell });
            }
            else if (cellDataType === COLUMN_DEF_DATATYPE_LINK) {
                return (h(ModusTableCellLinkElement, { link: cellValue, onLinkClick: (link) => {
                        this.cellEl.focus();
                        cellLinkClick.emit(link);
                    } }));
            }
            else if (cellDataType === COLUMN_DEF_DATATYPE_BADGE) {
                return (h(ModusTableCellBadgeElement, { badge: cellValue, onBadgeClick: () => {
                        this.cellEl.focus();
                    } }));
            }
            else {
                return CellFormatter(this.cell.column.columnDef.cell, this.cell.getContext());
            }
        };
        return (h("div", { class: classes }, this.hasRowsExpandable && h(ModusTableCellExpandIcons, { row: row }), h("span", { class: wrap ? 'wrap-text' : 'truncate-text' }, renderCell())));
    }
    createErrorTooltip() {
        if (!this.errorTooltip) {
            this.errorTooltip = document.createElement('div');
            this.errorTooltip.className = 'error-tooltip';
            this.cellEl.appendChild(this.errorTooltip);
            this.popperInstance = createPopper(this.cellEl, this.errorTooltip, {
                placement: 'bottom-start',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [0.2, 0.2], // Offset from the element
                            mainAxis: false,
                        },
                    },
                    {
                        name: 'preventOverflow',
                        options: {
                            boundary: 'viewport',
                        },
                    },
                ],
            });
        }
    }
    showErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.innerText = 'Invalid Input';
            this.errorTooltip.style.display = 'block';
            if (this.popperInstance) {
                this.popperInstance.update();
            }
        }
    }
    hideErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.style.display = 'none';
        }
    }
    destroyErrorTooltip() {
        if (this.popperInstance) {
            this.popperInstance.destroy();
            this.popperInstance = null;
        }
        if (this.errorTooltip) {
            this.errorTooltip.remove();
            this.errorTooltip = null;
        }
    }
    render() {
        var _a;
        const valueString = (_a = this.cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString();
        return (h(Host, { key: 'f83e4a3516e7e09c5ac025e612e16444e9a124dc' }, this.editMode ? (h("modus-table-cell-editor", { "data-type": this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY], value: this.cell.getValue(), type: this.getEditorType(), args: this.getEditorArgs(), valueChange: (newVal) => this.handleCellEditorValueChange(newVal, valueString), keyDown: (event, newVal) => this.handleCellEditorKeyDown(event, newVal, valueString), inputValueChangeHandler: (newVal) => this.handleCellEditorOnInputChange(newVal, valueString) })) : (this.renderCellValue())));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "editMode": ["onEditModeChange"],
        "context": ["onContextChange"]
    }; }
};

const modusTableFillerColumnCss = "modus-table-filler-column{z-index:0}modus-table-filler-column .d-none{display:none}modus-table-filler-column table thead tr,modus-table-filler-column table tfoot tr{height:inherit}modus-table-filler-column table:not(.cell-borderless) td:last-child,modus-table-filler-column table:not(.cell-borderless) th:last-child{border-right:none}modus-table-filler-column table:not(.cell-borderless) tbody td:first-child,modus-table-filler-column table:not(.cell-borderless) thead th:first-child{border-left:0.0625rem var(--modus-table-border-color, #b7b9c3) solid !important}";
const ModusTableFillerColumnStyle0 = modusTableFillerColumnCss;

const ModusTableFillerColumn = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.observer = null;
        this.updateContainerLayout = () => {
            var _a, _b, _c, _d, _e, _f;
            const tableWidth = (_a = this.targetTable.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a.width;
            const parentWidth = (_c = (_b = this.targetTable.parentElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.width;
            this.showFillerTable = tableWidth < parentWidth;
            if (!this.showFillerTable)
                return;
            if (this.fillerTableRef) {
                this.fillerTableRef.querySelector('thead').style.height = `${(_d = this.targetTable.querySelector('thead')) === null || _d === void 0 ? void 0 : _d.getBoundingClientRect().height}px`;
                if (this.summaryRow) {
                    this.fillerTableRef.querySelector('tfoot').style.height = `${(_e = this.targetTable.querySelector('tfoot')) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect().height}px`;
                }
                this.fillerTableRef.querySelector('tbody').style.height = `${(_f = this.targetTable.querySelector('tbody')) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect().height}px`;
            }
        };
        this.cellBorderless = undefined;
        this.summaryRow = undefined;
        this.container = undefined;
        this.showFillerTable = false;
    }
    componentDidLoad() {
        this.targetTable = this.container.shadowRoot.querySelector('table');
        if (this.targetTable) {
            this.updateContainerLayout();
            this.connectDOMObserver();
        }
    }
    disconnectedCallback() {
        this.disconnectDOMObserver();
    }
    connectDOMObserver() {
        this.observer = new ResizeObserver(this.updateContainerLayout);
        this.observer.observe(this.targetTable);
    }
    disconnectDOMObserver() {
        if (this.observer) {
            this.observer.disconnect();
        }
    }
    render() {
        return (h("table", { key: '8c5d31136767a6da879b04edca26d4da23e667a5', id: "table-filler-column", class: { 'cell-borderless': this.cellBorderless, 'd-none': !this.showFillerTable }, ref: (el) => (this.fillerTableRef = el) }, h("thead", { key: '458db94209103de571922b9b0bb05146c8033f45' }, h("tr", { key: '560d80b509a9bc83f851e972d7d77f68bebfa085' }, h("th", { key: '760ed56de2d8d909e5e2e17b25b56148a85537ae' }))), h("tbody", { key: 'fc01fb5caf8078b4989268ddb2b56a27820e3d06' }, h("tr", { key: '1dda921e8ce27b3538ef858829c5215329319122' }, h("td", { key: '2b9208f58aa2f45dac97186d33433ce4e450382e' }))), this.summaryRow && (h("tfoot", null, h("tr", { class: "summary-row" }, h("td", null))))));
    }
};
ModusTableFillerColumn.style = ModusTableFillerColumnStyle0;

const ModusTableRowActionsCell = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.onCellKeyDown = (e) => this.handleCellKeydown(e);
        this.handleCellKeydown = (event) => {
            var _a, _b, _c;
            if (event.defaultPrevented)
                return;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (key === KEYBOARD_ENTER) {
                (_c = (_b = this.el.firstChild) === null || _b === void 0 ? void 0 : _b.firstChild) === null || _c === void 0 ? void 0 : _c.focusButton();
                event.stopPropagation();
            }
            else {
                NavigateTableCells({
                    eventKey: event.key,
                    cellElement: this.cellEl,
                });
            }
        };
        this.row = undefined;
        this.context = undefined;
    }
    connectedCallback() {
        this.cellEl = this.el.parentElement;
        this.cellEl.addEventListener('keydown', this.onCellKeyDown);
    }
    disconnectedCallback() {
        if (this.cellEl) {
            this.cellEl.removeEventListener('keydown', this.onCellKeyDown);
        }
    }
    render() {
        return (h(Host, { key: '99e83886c3f3c7adb4558b0ca6b4f67ad5b66763' }, h("modus-table-row-actions", { key: 'a40fb8324cd122292b9806cd66e28ff747c17b24', row: this.row, context: this.context })));
    }
    get el() { return getElement(this); }
};

const modusTableRowActionsMenuCss = "modus-table-row-actions-menu .row-actions-menu{background-color:var(--modus-table-bg, #fff);box-shadow:0 0 2px rgba(37, 42, 46, 0.3);color:var(--modus-table-body-color, #252a2e);display:flex;position:fixed;top:-1px;z-index:9}modus-table-row-actions-menu modus-list-item{cursor:pointer}";
const ModusTableRowActionsMenuStyle0 = modusTableRowActionsMenuCss;

const ModusTableRowActionsMenu = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // a local state to keep track of the overflow icon click to prevent `handleClickOutside` from closing the menu
        // event.preventDefault would not solve the problem when multiple tables are present on the page
        this.isOverflowIconClicked = false;
        this.onOverflowRowActions = (e) => this.handleOverflowRowActions(e);
        this.onRowActionClick = (e) => this.handleRowActionButtonClick(e);
        this.onRowExpanded = () => (this.isMenuOpen = false);
        this.context = undefined;
        this.isMenuOpen = false;
        this.overFlowMenu = undefined;
        this.position = undefined;
        this.menuWidth = 0;
    }
    onMenuOpenChange(newValue) {
        if (!newValue) {
            this.overFlowMenu = null;
            this.position = null;
            this.tableRow = null;
        }
    }
    componentDidRender() {
        var _a;
        if (this.isMenuOpen) {
            const firstItem = (_a = Array.from(this.element.querySelectorAll('modus-list-item'))) === null || _a === void 0 ? void 0 : _a.find((el) => !el.disabled);
            firstItem === null || firstItem === void 0 ? void 0 : firstItem.focusItem();
            // Calculate and set the rowAction menu width
            const menuElement = this.element.querySelector('.row-actions-menu');
            if (menuElement) {
                this.menuWidth = menuElement.offsetWidth;
            }
        }
    }
    connectedCallback() {
        const { element } = this.context;
        element.addEventListener('overflowRowActions', this.onOverflowRowActions);
        element.addEventListener('rowActionClick', this.onRowActionClick);
        element.addEventListener('rowExpanded', this.onRowExpanded);
    }
    disconnectedCallback() {
        const { element } = this.context;
        element.removeEventListener('overflowRowActions', this.onOverflowRowActions);
        element.removeEventListener('rowActionClick', this.onRowActionClick);
        element.removeEventListener('rowExpanded', this.onRowExpanded);
    }
    handleOverflowRowActions(event) {
        var _a;
        const { componentId, actions, position, row, onClose } = event.detail;
        if (componentId !== this.context.componentId)
            return;
        this.isMenuOpen = ((_a = this.tableRow) === null || _a === void 0 ? void 0 : _a.id) === row.id ? false : true;
        if (this.isMenuOpen) {
            this.overFlowMenu = actions;
            this.position = position;
            this.tableRow = row;
            this.onCloseMenu = onClose;
        }
        this.isOverflowIconClicked = this.isMenuOpen;
        event.stopPropagation();
    }
    handleRowActionButtonClick({ detail: { actionId } }) {
        const rowActionButtonClicked = this.overFlowMenu && this.overFlowMenu.find((action) => action.id !== actionId);
        if (rowActionButtonClicked)
            this.isMenuOpen = false;
    }
    handleClickOutside(event) {
        if (!(this.element.contains(event.target) || this.isOverflowIconClicked)) {
            this.isMenuOpen = false;
        }
        this.isOverflowIconClicked = false;
    }
    handleListItemClick(id) {
        const { rowActionClick } = this.context;
        rowActionClick.emit({ actionId: id, row: this.tableRow.original });
    }
    handleListItemKeydown(e) {
        var _a;
        if (e.key.toLowerCase() === 'escape' || e.key.toLowerCase() === 'enter') {
            this.isMenuOpen = false;
            (_a = this.onCloseMenu) === null || _a === void 0 ? void 0 : _a.call(this);
            e.preventDefault();
        }
    }
    render() {
        var _a;
        if (!(((_a = this.overFlowMenu) === null || _a === void 0 ? void 0 : _a.length) && this.position))
            return null;
        const { x, y } = this.position;
        const style = {
            transform: `translate(calc(${x - this.menuWidth / 1.5}px - 8px), calc(${y}px))`,
        };
        return (h(Host, null, this.isMenuOpen && (h("div", { style: Object.assign({}, style), class: "row-actions-menu" }, h("modus-list", { class: "hydrated" }, this.overFlowMenu.map(({ label, id, icon, iconColor, isDisabled = () => false }) => {
            var _a;
            const disabled = isDisabled((_a = this.tableRow) === null || _a === void 0 ? void 0 : _a.original);
            return (h("modus-list-item", { style: { maxWidth: '155px' }, leftIcon: icon, iconColor: iconColor, disabled: disabled, onItemClick: () => this.handleListItemClick(id), class: "hydrated row-actions-menu-item", onKeyDown: (e) => this.handleListItemKeydown(e), tabindex: disabled ? -1 : 0 }, label));
        }))))));
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "isMenuOpen": ["onMenuOpenChange"]
    }; }
};
ModusTableRowActionsMenu.style = ModusTableRowActionsMenuStyle0;

const modusTableToolbarCss = ".table-toolbar{align-items:center;display:flex;justify-content:space-between;padding-bottom:3px}.table-toolbar .section{align-items:center;display:flex}";
const ModusTableToolbarStyle0 = modusTableToolbarCss;

const ModusTablePanel = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.context = undefined;
    }
    render() {
        // const { tableInstance: table, toolbarOptions: options } = this.context;
        return (h(Host, { key: 'd8b9a5275dc4e77bdacb4958d1cdd4079872302c' }, h("div", { key: '5f5d87db6a9cd8dd774e055396fd12679d8c534e', class: "table-toolbar" }, h("div", { key: '432d5965c73c369d63e55f81ce300dc9c52caee6', class: "section" }, h("slot", { key: '11786f71e2d0a2ac80bbf56a5e3de148a57de865', name: "group-left" })), h("div", { key: '2b515ed9f8869b8c16ef478deb87fb5f629182cf', class: "section" }, h("slot", { key: 'ea1db6297b8534aa58ed9c5a5793b810ff7b8dc3', name: "group-right" }), h("modus-table-dropdown-menu", { context: this.context })))));
    }
};
ModusTablePanel.style = ModusTableToolbarStyle0;

export { ModusPagination as modus_pagination, ModusTableCellMain as modus_table_cell_main, ModusTableFillerColumn as modus_table_filler_column, ModusTableRowActionsCell as modus_table_row_actions_cell, ModusTableRowActionsMenu as modus_table_row_actions_menu, ModusTablePanel as modus_table_toolbar };
