import { r as registerInstance, h, g as getElement, H as Host, c as createEvent } from './index-612c46d2.js';
import { I as IconSearch } from './icon-search-c09d65cf.js';
import { g as generateElementId, c as createGuid } from './utils-3803a333.js';
import { d as IconCheck, M as ModusIconMap } from './ModusIconMap-c226cf23.js';
import { I as IconClose } from './icon-close-fdd297f4.js';
import { s as CELL_EDIT_TYPE_TEXT, x as CELL_EDIT_TYPE_INT, y as CELL_EDIT_TYPE_DATE, z as CELL_EDIT_TYPE_AUTOCOMPLETE, B as CELL_EDIT_TYPE_SELECT, p as KEYBOARD_UP, q as KEYBOARD_DOWN, f as KEYBOARD_ENTER } from './modus-table.constants-3cf5de92.js';
import './IconChevronLeft-dfd06381.js';
import './IconChevronRight-5734b74b.js';
import './IconClose-be97678b.js';
import './IconExpand-ccaa9f2c.js';
import './IconVisibilityOn-6945ca0c.js';

const FlexRenderer = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.content = '';
    }
    componentDidLoad() {
        this.renderHTMLContent();
    }
    renderHTMLContent() {
        const htmlString = this.content.trim();
        const parsedElements = this.parseHTMLString(htmlString);
        const shadowRoot = this.el.shadowRoot;
        if (shadowRoot) {
            parsedElements.forEach((element) => {
                shadowRoot.appendChild(element);
            });
        }
    }
    parseHTMLString(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const elements = Array.from(doc.body.childNodes);
        return elements.map((element) => this.createElementFromNode(element));
    }
    createElementFromNode(node) {
        const element = document.createElement(node.tagName.toLowerCase());
        Array.from(node.attributes).forEach((attr) => {
            element.setAttribute(attr.name, attr.value);
        });
        if (node.childNodes.length > 0) {
            node.childNodes.forEach((child) => {
                if (child.nodeType === Node.TEXT_NODE) {
                    element.appendChild(document.createTextNode(child.textContent));
                }
                else if (child.nodeType === Node.ELEMENT_NODE) {
                    element.appendChild(this.createElementFromNode(child));
                }
            });
        }
        return element;
    }
    render() {
        return h(Host, { key: 'f1d1844c4dc3c40709804bd3c061ad15aec2e0da' });
    }
    get el() { return getElement(this); }
};

const modusAutocompleteCss = ".autocomplete{position:relative}.autocomplete ul{list-style-type:none;margin:0;padding:0}.autocomplete label{color:var(--modus-autocomplete-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.autocomplete .label-container{display:inline-block;margin-bottom:0.25rem}.autocomplete .label-container .required{bottom:0.0625rem;color:var(--modus-autocomplete-validation-error-color, #da212c);margin-left:0.25rem;position:relative}.autocomplete .chips-container{align-items:center;background-color:var(--modus-autocomplete-bg, #fff);border:var(--modus-autocomplete-border, 0.0625rem solid var(--modus-input-border-color, #6a6e79));border-bottom-color:var(--modus-input-border-color, #6a6e79);border-radius:4px;box-sizing:border-box;display:flex;flex-flow:row wrap;height:auto;margin:0;min-height:32px;padding:0;position:relative;width:100%}.autocomplete .chips-container.clearable-icon{padding-right:32px}.autocomplete .chips-container:focus-within{border-color:var(--modus-input-border-active-line-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-line-color, #217cbb)}.autocomplete .chips-container .icon-search{margin-left:4px;margin-right:0}.autocomplete .chips-container modus-chip{margin-left:4px;margin-right:4px;overflow:hidden}.autocomplete .chips-container .autocomplete-chip::part(chipButton){max-width:100%}.autocomplete .chips-container .input{display:flex;flex:1;height:auto !important;position:relative;--input-font-size:var(--modus-autocomplete-font-size, 12px)}.autocomplete .chips-container .input::part(input-container){border:none !important;box-shadow:none;height:1.875rem;min-width:30px}.autocomplete .chips-container .icons{align-items:center;color:var(--modus-input-helper-icon-color, #6a6e79);cursor:pointer;display:flex;font-size:1rem;height:100%;justify-content:center;margin-left:1px;width:2rem}.autocomplete .chips-container .icons.clear{cursor:pointer;min-height:1.875rem;position:absolute;right:0}.autocomplete .chips-container .icons.clear:hover svg path{opacity:0.75}.autocomplete .error{color:var(--modus-autocomplete-validation-error-color, #da212c)}.autocomplete .options-container{background-color:var(--modus-list-item-bg, #fff);border-radius:4px;box-shadow:0 0 4px rgba(36, 35, 45, 0.3);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin:0;padding:0;position:absolute;width:100%}.autocomplete .options-container .icon-check{display:inline-flex;flex-shrink:0;margin-left:auto}.autocomplete .options-container .text-option{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);color:var(--modus-list-item-color, #252a2e);cursor:pointer;display:flex;flex-direction:row;font-size:0.75rem;min-height:2rem;padding:0 8px;word-break:break-all}.autocomplete .options-container .text-option.selected{background-color:var(--modus-blue-pale, #dcedf9)}.autocomplete .options-container .text-option.selected .highlight-text{color:var(--modus-blue, #0063a3)}.autocomplete .options-container .text-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .text-option:focus{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .text-option .highlight-text{font-weight:bold}.autocomplete .options-container .custom-option{border:1px solid var(--modus-list-item-border-color, #e0e1e9);cursor:pointer}.autocomplete .options-container .custom-option.selected{background-color:var(--modus-blue-pale, #dcedf9)}.autocomplete .options-container .custom-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .custom-option:focus{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .spinner-container{display:flex;justify-content:center;padding:4px}.autocomplete .options-container .no-results{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);border-radius:4px;display:flex;flex-direction:column;height:100px;justify-content:center}.autocomplete .options-container .no-results path{fill:var(--modus-autocomplete-no-results-message-color, #252a2e)}.autocomplete .options-container .no-results .message{color:var(--modus-autocomplete-no-results-message-color, #252a2e);font-size:1.25rem;font-weight:600;margin:0 0 0.375rem 0.25rem}.autocomplete .options-container .no-results .subtext{color:var(--modus-autocomplete-no-results-subtext-color, #252a2e);font-size:0.875rem}.autocomplete.large .chips-container .input::part(input-container){height:3rem}.autocomplete.large .icon-search{margin-left:8px}.autocomplete.large .options-container>.text-option{font-size:0.875rem;min-height:3rem;padding:0 1rem}.autocomplete[aria-readonly=true] .chips-container{background-color:var(--modus-autocomplete-readonly-bg, #e0e1e9);border-color:transparent}.autocomplete[aria-readonly=true] .chips-container .input::part(input-container){background-color:var(--modus-autocomplete-readonly-bg, #e0e1e9);border-color:transparent;color:var(--modus-autocomplete-readonly-color, #a3a6b1)}.autocomplete[aria-disabled=true] .chips-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent;pointer-events:none;user-select:none}.autocomplete[aria-disabled=true] .chips-container .input::part(input-container){background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent;color:var(--modus-input-disabled-color, #a3a6b1);pointer-events:none;user-select:none}";
const ModusAutocompleteStyle0 = modusAutocompleteCss;

const DATA_ID = 'data-id';
const DATA_SEARCH_VALUE = 'data-search-value';
const ModusAutocomplete = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.optionSelected = createEvent(this, "optionSelected", 7);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.selectionsChanged = createEvent(this, "selectionsChanged", 7);
        this.listId = generateElementId() + '_list';
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.displayNoResults = () => {
            var _a, _b, _c;
            return !this.loading &&
                this.showNoResultsFoundMessage &&
                this.hasFocus &&
                !((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.length) &&
                !((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.length) &&
                ((_c = this.value) === null || _c === void 0 ? void 0 : _c.length) > 0 &&
                !this.readOnly;
        };
        this.displayOptions = () => {
            var _a;
            const showOptions = this.showOptionsOnFocus || ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.disableCloseOnSelect || this.ShowItemsOnKeyDown;
            return !this.loading && this.hasFocus && showOptions && !this.disabled && !this.readOnly;
        };
        this.handleCustomOptionClick = (option) => {
            const optionValue = option.getAttribute(DATA_SEARCH_VALUE);
            const optionId = option.getAttribute(DATA_ID);
            if (this.multiple) {
                this.addChipValue({ id: optionId, value: optionValue });
            }
            else {
                this.selectedOption = optionValue;
                this.disableFiltering = this.disableCloseOnSelect;
                this.handleSearchChange(optionValue);
                this.focusItemIndex = this.visibleCustomOptions.findIndex((el) => el.getAttribute(DATA_ID) === optionId);
            }
            this.hasFocus = this.disableCloseOnSelect;
            this.optionSelected.emit(optionId);
        };
        this.handleInputBlur = () => {
            this.hasFocus = !this.disableCloseOnSelect;
        };
        this.handleKeyDown = (event) => {
            if (event.defaultPrevented) {
                return; // Do nothing if event already handled
            }
            if (event.code.toUpperCase() === 'ARROWDOWN') {
                this.ShowItemsOnKeyDown = true;
                if (this.displayOptions() && !this.displayNoResults()) {
                    this.focusItemIndex = 0;
                    this.focusOptionItem();
                }
            }
            else if (event.code.toUpperCase() === 'ESCAPE') {
                this.ShowItemsOnKeyDown = false;
            }
        };
        this.handleOptionKeyDown = (event, option, isCustomOption = false) => {
            this.disableFiltering = !this.disableCloseOnSelect;
            switch (event.key.toUpperCase()) {
                case 'ENTER':
                case ' ':
                    if (isCustomOption) {
                        this.handleCustomOptionClick(option);
                    }
                    else {
                        this.handleOptionClick(option);
                    }
                    break;
                case 'ARROWDOWN':
                    if (isCustomOption) {
                        this.handleArrowDown(this.visibleCustomOptions);
                    }
                    else {
                        this.handleArrowDown(this.visibleOptions);
                    }
                    event.preventDefault();
                    break;
                case 'ARROWUP':
                    this.handleArrowUp();
                    break;
                default:
                    return;
            }
        };
        this.handleOptionClick = (option) => {
            if (this.multiple) {
                this.addChipValue(option);
            }
            else {
                this.selectedOption = option.value;
                this.disableFiltering = this.disableCloseOnSelect;
                this.focusItemIndex = this.visibleOptions.findIndex((el) => el.id === option.id);
                this.handleSearchChange(option.value);
            }
            this.hasFocus = this.disableCloseOnSelect;
            this.optionSelected.emit(option.id);
        };
        this.handleArrowDown = (options) => {
            this.focusItemIndex = Math.min(options.length - 1, this.focusItemIndex + 1);
            this.focusOptionItem();
        };
        this.handleInputKeyDown = (e) => {
            if (e.defaultPrevented) {
                return; // Do nothing if event already handled
            }
            if (e.key === 'Backspace' && this.multiple && !this.getValueAsString() && this.selectedChips.length > 0) {
                this.selectedChips = this.selectedChips.slice(0, -1);
                this.valueChange.emit(this.selectedChips.map((opt) => opt.value));
                this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
            }
        };
        this.handleArrowUp = () => {
            this.focusItemIndex = Math.max(0, this.focusItemIndex - 1);
            this.focusOptionItem();
        };
        this.focusOptionItem = () => {
            var _a;
            (_a = this.el.shadowRoot.querySelectorAll('[role="option"]')[this.focusItemIndex]) === null || _a === void 0 ? void 0 : _a.focus();
        };
        this.handleSearchChange = (search, skipFiltering = false) => {
            if (!skipFiltering) {
                this.updateVisibleOptions(search);
                this.updateVisibleCustomOptions(search);
            }
            this.value = search;
            this.valueChange.emit(search);
        };
        this.handleChipDelete = (e, chip) => {
            if (e.key !== 'Delete') {
                return;
            }
            this.removeChip(chip);
        };
        this.handleTextInputFocus = () => {
            var _a;
            const hasDefaultTextInput = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 && !this.disableCloseOnSelect;
            if (hasDefaultTextInput) {
                this.disableFiltering = true;
            }
        };
        this.handleTextInputValueChange = (event) => {
            var _a;
            if (typeof this.filterOptions === 'function') {
                const tempValue = event.detail;
                this.handleSearchChange(tempValue, true);
                (_a = this.filterOptions(tempValue)) === null || _a === void 0 ? void 0 : _a.then((filteredOptions) => {
                    const currentValue = this.getValueAsString();
                    if (tempValue !== currentValue) {
                        return;
                    }
                    const transformedOptions = filteredOptions[0] && typeof filteredOptions[0] === 'string'
                        ? this.stringToOption(filteredOptions)
                        : filteredOptions;
                    this.options = transformedOptions;
                    this.visibleOptions = transformedOptions;
                });
            }
            else {
                // Cancel the modus-text-input's value change event or else it will bubble to consumer.
                event.stopPropagation();
                this.disableFiltering = !this.disableCloseOnSelect;
                this.handleSearchChange(event.detail);
            }
        };
        this.updateVisibleCustomOptions = (search = '') => {
            var _a, _b;
            if (!this.hasFocus) {
                return;
            }
            const slotted = (_a = this.el.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
            if (!slotted || typeof slotted.assignedNodes !== 'function') {
                return;
            }
            this.customOptions = slotted.assignedNodes().filter((node) => node.nodeName !== '#text');
            search = search || '';
            const isSearchEmpty = search.length === 0;
            if (isSearchEmpty) {
                this.selectedOption = '';
            }
            if (!this.disableFiltering) {
                this.visibleCustomOptions = (_b = this.customOptions) === null || _b === void 0 ? void 0 : _b.filter((o) => {
                    var _a;
                    return (_a = o.getAttribute(DATA_SEARCH_VALUE)) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(search === null || search === void 0 ? void 0 : search.toLowerCase());
                });
            }
            else {
                this.visibleCustomOptions = this.customOptions;
            }
            this.containsSlottedElements = this.customOptions.length > 0;
        };
        this.updateVisibleOptions = (search = '') => {
            var _a;
            if (!this.hasFocus) {
                return;
            }
            search = search || '';
            const isSearchEmpty = search.length === 0;
            if (isSearchEmpty) {
                this.selectedOption = '';
            }
            if (!this.disableFiltering) {
                this.visibleOptions = (_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.filter((o) => {
                    var _a;
                    return (_a = o === null || o === void 0 ? void 0 : o.value) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(search === null || search === void 0 ? void 0 : search.toLowerCase());
                });
            }
            else {
                this.visibleOptions = this === null || this === void 0 ? void 0 : this.options;
            }
        };
        this.getHighlightedText = (text, search) => {
            if (!search)
                return text;
            const escapedSearch = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedSearch, 'gi');
            const highlightedText = text.replace(regex, (match) => `<span class="highlight-text">${match}</span>`);
            return h("span", { innerHTML: highlightedText });
        };
        // Do not display the slot for the custom options. We use this hidden slot to reference the slot's children.
        this.CustomOptionsSlot = () => (h("div", { style: { display: 'none' } }, h("slot", { onSlotchange: () => this.updateVisibleCustomOptions(this.getValueAsString()) })));
        this.TextInput = () => (h("modus-text-input", { class: "input", autocomplete: "off", includeSearchIcon: false, onFocus: this.handleTextInputFocus, onValueChange: (searchEvent) => this.handleTextInputValueChange(searchEvent), placeholder: this.placeholder, size: this.size, type: "search", value: this.getValueAsString(), onBlur: this.handleInputBlur, onKeyDown: (e) => this.handleInputKeyDown(e), role: "combobox", disabled: this.disabled, readOnly: this.readOnly, "aria-autocomplete": "list", "aria-controls": this.listId, "aria-expanded": this.displayOptions() }));
        this.scrollToOptionSelected = () => {
            if (this.multiple || this.focusItemIndex === 0) {
                return;
            }
            const optionList = this.el.shadowRoot.querySelector(`.options-container`);
            const selectedOption = optionList.querySelector('li.selected');
            if (selectedOption) {
                selectedOption.scrollIntoView({ behavior: 'smooth', inline: 'nearest' });
            }
        };
        this.multiple = undefined;
        this.ariaLabel = undefined;
        this.clearable = false;
        this.disabled = undefined;
        this.disableCloseOnSelect = undefined;
        this.dropdownMaxHeight = '300px';
        this.dropdownZIndex = '1';
        this.errorText = undefined;
        this.includeSearchIcon = true;
        this.label = undefined;
        this.noResultsFoundText = 'No results found';
        this.noResultsFoundSubtext = 'Check spelling or try a different keyword';
        this.options = undefined;
        this.filterOptions = undefined;
        this.selectedChips = [];
        this.selectedOption = undefined;
        this.loading = false;
        this.showOptionsOnFocus = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.showNoResultsFoundMessage = true;
        this.size = 'medium';
        this.value = undefined;
        this.containsSlottedElements = false;
        this.hasFocus = false;
        this.visibleOptions = [];
        this.customOptions = [];
        this.visibleCustomOptions = [];
        this.disableFiltering = false;
        this.focusItemIndex = 0;
        this.ShowItemsOnKeyDown = false;
    }
    watchOptions() {
        this.convertOptions();
        this.updateVisibleOptions(this.getValueAsString());
    }
    onValueChange() {
        if (this.hasFocus && !this.disableCloseOnSelect) {
            this.disableFiltering = false;
            this.updateVisibleOptions(this.getValueAsString());
            this.updateVisibleCustomOptions(this.getValueAsString());
        }
        if (this.multiple && Array.isArray(this.value)) {
            if (this.value.length) {
                this.initializeSelectedChips();
            }
            else {
                this.handleClear();
                this.errorText = '';
            }
        }
    }
    componentWillLoad() {
        this.convertOptions();
        if (this.multiple) {
            this.initializeSelectedChips();
        }
    }
    componentDidRender() {
        if (this.displayOptions()) {
            this.scrollToOptionSelected();
        }
    }
    /** Focus the autocomplete component */
    async focusInput() {
        const textInputElement = this.el.shadowRoot.querySelector('modus-text-input');
        if (textInputElement) {
            textInputElement.focusInput();
        }
    }
    onMouseDown(event) {
        if (!this.hasFocus) {
            return;
        }
        if (this.el !== event.target || !this.el.contains(event.target)) {
            this.hasFocus = false;
            this.ShowItemsOnKeyDown = false;
        }
    }
    stringToOption(options) {
        return options === null || options === void 0 ? void 0 : options.map((option) => ({
            id: option,
            value: option,
        }));
    }
    convertOptions() {
        if (this.options && this.options.length > 0) {
            if (typeof this.options[0] === 'string') {
                this.options = this.stringToOption(this.options);
            }
        }
    }
    addChipValue(value) {
        if (this.selectedChips.some((chip) => chip.id === value.id)) {
            return;
        }
        this.selectedChips = [...this.selectedChips, value];
        this.valueChange.emit(this.selectedChips.map((opt) => opt.value));
        this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
        this.value = '';
    }
    handleClear() {
        this.selectedChips = [];
        this.selectedOption = '';
        this.value = '';
        this.valueChange.emit(this.multiple ? [] : '');
        this.selectionsChanged.emit(this.multiple ? [] : null);
    }
    handleClearKeyDown(event) {
        if (event.key !== 'Enter' && event.key !== ' ') {
            return;
        }
        this.handleClear();
    }
    getValueAsString() {
        if (this.value && Array.isArray(this.value)) {
            return '';
        }
        if (this.value && typeof this.value === 'string') {
            return this.value;
        }
        return '';
    }
    initializeSelectedChips() {
        if (Array.isArray(this.value)) {
            const val = this.value.map((v) => v.trim());
            const filteredOptions = this.options.filter((option) => val.includes(option.value));
            this.selectedChips = filteredOptions;
            this.valueChange.emit(this.selectedChips.map((opt) => opt.value));
            this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
        }
    }
    handleCloseClick(chipValue) {
        this.removeChip(chipValue);
    }
    removeChip(chipValue) {
        if (this.selectedChips.length != 0 && !this.readOnly) {
            this.selectedChips = this.selectedChips.filter((chip) => chip.id !== chipValue.id);
            this.valueChange.emit(this.selectedChips.map((v) => v.value));
            this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
        }
    }
    valueChangedHandler(event) {
        if (event.detail == null) {
            this.handleClear();
        }
    }
    render() {
        var _a, _b;
        const classes = `autocomplete ${this.classBySize.get(this.size)}`;
        const iconSize = this.size === 'large' ? '24' : '16';
        const showClearIcon = this.clearable && !this.readOnly && !this.disabled && (!!this.value || this.selectedChips.length > 0);
        return (h("div", { key: '2e1d65aa5f02f1199b0c3e63ed4ab81da41a6062', "aria-disabled": this.disabled ? 'true' : undefined, "aria-invalid": !!this.errorText, "aria-label": this.ariaLabel || undefined, "aria-readonly": this.readOnly ? 'true' : undefined, "aria-required": this.required, class: classes, onFocusin: () => {
                if (this.hasFocus) {
                    return;
                }
                this.hasFocus = true;
                this.updateVisibleOptions(this.getValueAsString());
                this.updateVisibleCustomOptions(this.getValueAsString());
            }, onFocusout: () => {
                if (this.hasFocus) {
                    this.hasFocus = this.disableCloseOnSelect;
                }
            }, onKeyDown: (e) => this.handleKeyDown(e) }, this.label || this.required ? (h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null)) : null, h("div", { key: 'c11b8a67b60820fb603bb517861083f3e2defb1c', class: `chips-container ${this.clearable ? 'clearable-icon' : ''}` }, this.includeSearchIcon ? h(IconSearch, { size: "16" }) : null, this.selectedChips.map((chip) => (h("modus-chip", { class: "autocomplete-chip", tabIndex: this.disabled ? -1 : 0, value: chip.value, chipId: chip.id, disabled: this.disabled, onKeyDown: (e) => this.handleChipDelete(e, chip), size: this.size === 'large' ? 'medium' : 'small', "show-close": true, onCloseClick: () => this.handleCloseClick(chip) }))), this.TextInput(), showClearIcon && (h("span", { class: "icons clear", tabIndex: 0, onKeyDown: (event) => this.handleClearKeyDown(event), onClick: () => this.handleClear(), role: "button", "aria-label": "Clear entry" }, h(IconClose, { size: iconSize })))), h("div", { key: 'a99555ba4a09030b1e646b2068ab835e16d479ce', class: 'error' }, this.errorText ? h("label", { class: "sub-text error" }, this.errorText) : null), h("div", { key: 'e3441ad7714adbdea717b2881d94b7a3f1038959', class: "options-container", style: { maxHeight: this.dropdownMaxHeight, zIndex: this.dropdownZIndex, overflowY: 'auto' } }, h("ul", { key: '89aeef4adc34adad8f45eeb3b893d2c79e88a2c9', id: this.listId, "aria-label": "options", role: "listbox" }, this.displayOptions() &&
            ((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.map((option) => {
                let className;
                let isSelected;
                if (this.multiple) {
                    isSelected = this.selectedChips.includes(option);
                    className = 'text-option' + (isSelected ? ' selected' : '');
                }
                else {
                    isSelected = this.selectedOption === option.value;
                    className = 'text-option' + (isSelected ? ' selected' : '');
                }
                return (h("li", { class: className, tabindex: "-1", role: "option", onMouseDown: () => this.handleOptionClick(option), onKeyDown: (e) => this.handleOptionKeyDown(e, option) }, this.getHighlightedText(option.value, this.getValueAsString()), isSelected && h(IconCheck, { size: "16" })));
            })), this.displayOptions() &&
            ((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.map((option) => {
                const optionValue = option.getAttribute(DATA_SEARCH_VALUE);
                const isSelected = this.selectedChips.some((chip) => chip.value === optionValue);
                let className;
                if (this.multiple) {
                    className = 'custom-option' + (isSelected ? ' selected' : '');
                }
                else {
                    className = 'custom-option' + (this.selectedOption === optionValue ? ' selected' : '');
                }
                return (h("li", { class: className, tabindex: "-1", role: "option", onMouseDown: () => this.handleCustomOptionClick(option), onKeyDown: (e) => this.handleOptionKeyDown(e, option, true), innerHTML: option.outerHTML }));
            }))), this.loading ? (h(LoadingSpinner, null)) : (this.displayNoResults() && h(NoResultsFound, { text: this.noResultsFoundText, subtext: this.noResultsFoundSubtext }))), this.CustomOptionsSlot()));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "options": ["watchOptions"],
        "value": ["onValueChange"]
    }; }
};
const NoResultsFound = (props) => (h("div", { class: "no-results" }, h("div", { style: { display: 'flex' } }, h(IconSearch, { size: "28px" }), h("div", { class: "message" }, props.text)), h("div", { class: "subtext" }, props.subtext)));
const LoadingSpinner = () => (h("div", { class: "spinner-container" }, h("modus-spinner", { size: "1.5rem" })));
ModusAutocomplete.style = ModusAutocompleteStyle0;

const monthsFull = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const monthsShort = monthsFull.map((m) => m.substring(0, 3));
function pad(val) {
    if (val < 10)
        return `0${val}`;
    return val.toString();
}
//date.toLocaleString('en-US', { month: 'short' })
const Tokens = {
    mmmm: { regex: `(${monthsFull.join('|')})`, type: 'month' },
    mmm: { regex: `(${monthsShort.join('|')})`, type: 'month' },
    mm: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    m: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    dd: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    d: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    yy: { regex: '(\\d{2})', type: 'year' },
    yyyy: { regex: '(\\d{4})', type: 'year' },
};
const TokenFormatting = {
    m: function (val) {
        return `${val}`;
    },
    mm: function (val) {
        return pad(val);
    },
    mmm: function (val) {
        return monthsShort[val - 1];
    },
    mmmm: function (val) {
        return monthsFull[val - 1];
    },
    d: function (val) {
        return `${val}`;
    },
    dd: function (val) {
        return pad(val);
    },
    yy: function (val) {
        return pad(val).substring(2);
    },
    yyyy: function (val, fillerYear) {
        if (val < 100) {
            const fill = fillerYear || new Date().getFullYear();
            return `${String(fill).substring(0, 2)}${pad(val)}`;
        }
        else
            return `${val}`;
    },
};
const defaultParser = function (val) {
    return parseFloat(val);
};
const TokenParser = {
    m: defaultParser,
    mm: defaultParser,
    mmm: function (val) {
        return monthsShort.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    mmmm: function (val) {
        return monthsFull.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    d: defaultParser,
    dd: defaultParser,
    yy: defaultParser,
    yyyy: defaultParser,
};

const ISO_DATE_FORMAT = /^(\d{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])/;
class DateInputFormatter {
    constructor(fillerDateString, format) {
        const [regex, tokens, separators] = this.buildRegexAndTokens(format);
        if (regex && tokens) {
            this._dateRegExp = regex;
            this._dateTokens = tokens;
            this._displayFormat = format;
            this._tokenSeparators = separators;
        }
        this._fillerDate = this.getFillerDate(fillerDateString);
    }
    /**
     * Note: Auto formatting is not used yet due to the challenges in handling formats like 'm' and 'd' where the user can input single or double-digit
     */
    autoFormatInput(val, autoFormat) {
        if (!val || !autoFormat)
            return val;
        const separator = this._tokenSeparators.get(val.length);
        if (separator) {
            return val + separator;
        }
        return val;
    }
    /**
     * Build a regular expression from the date format
     * Returns an array of regular expression, date tokens, token separators
     */
    buildRegexAndTokens(format) {
        const dtTokens = new Map();
        const regexParts = [];
        const separators = new Map();
        for (let i = 0; i < format.length; i++) {
            let token = format[i];
            const tokens = [token];
            while (format[i + 1] === token) {
                tokens.push(token);
                ++i;
            }
            const validToken = tokens.join('');
            const tokenInfo = Tokens[validToken];
            if (tokenInfo && tokenInfo.regex) {
                dtTokens.set(tokenInfo.type, {
                    index: dtTokens.size,
                    tokenString: validToken,
                });
                token = tokenInfo.regex;
            }
            else {
                separators.set(i, token);
            }
            regexParts.push(token);
        }
        return [`^${regexParts.join('')}$`, dtTokens, separators];
    }
    /** Format value in ISO 8601 date format to the display format */
    formatDisplayString(val) {
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            const parts = {
                year: parseFloat(parse[0]),
                month: parseFloat(parse[1]),
                date: parseFloat(parse[2]),
            };
            let output = this._displayFormat;
            this._dateTokens.forEach(({ tokenString }, key) => {
                const formatting = TokenFormatting[tokenString];
                output = output.replace(tokenString, formatting(parts[key], key === 'year' ? this._fillerDate.getFullYear() : null));
            });
            return output;
        }
        return null;
    }
    /** Parse display string to ISO 8601 date format YYYY-MM-DD */
    parseDisplayString(val) {
        if (this._dateRegExp && val) {
            const regexObj = new RegExp(this._dateRegExp, 'i');
            const output = regexObj.exec(val);
            if (output) {
                // parsed[0] always contains the whole string
                output.shift();
                const monthToken = this._dateTokens.get('month');
                const dateToken = this._dateTokens.get('date');
                const yearToken = this._dateTokens.get('year');
                const month = monthToken
                    ? TokenParser[monthToken.tokenString](output[monthToken.index])
                    : this._fillerDate.getMonth() + 1;
                const date = dateToken ? TokenParser[dateToken.tokenString](output[dateToken.index]) : this._fillerDate.getDate();
                const year = yearToken
                    ? TokenParser[yearToken.tokenString](output[yearToken.index])
                    : this._fillerDate.getFullYear();
                const isoDateString = `${TokenFormatting.yyyy(year, this._fillerDate.getFullYear())}-${TokenFormatting.mm(month)}-${TokenFormatting.dd(date)}`;
                return Date.parse(isoDateString) ? isoDateString : null;
            }
        }
        return null;
    }
    /**
     * Filler date is used as fillers for parts not in the display format when constructing a full date string,
     * ex: 'yyyy-mm' format doesn't have a date part, hence the date is picked from filler  */
    getFillerDate(val) {
        return this.parseIsoToDate(val) || new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0);
    }
    parseIsoToDate(val) {
        if (!val) {
            return null;
        }
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, parseFloat(parse[2]));
        }
        return null;
    }
}

const modusDateInputCss = ".modus-date-input{box-sizing:border-box;display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-input button{background:0;border:0;cursor:pointer;margin:0;padding:0}.modus-date-input label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.modus-date-input label span{color:var(--modus-input-border-color, #6a6e79);margin:0.25rem}.modus-date-input .label-container{display:flex}.modus-date-input .label-container .required{bottom:0.0625rem;color:var(--modus-input-validation-error-color, #da212c);margin-left:0.25rem;position:relative}.modus-date-input .input-container{align-items:center;background-color:var(--modus-input-bg, #fff);border:0.0625rem solid var(--modus-input-border-color, #6a6e79);border-radius:4px;box-sizing:border-box;display:flex;flex-direction:row;height:2rem;position:relative;width:100%}.modus-date-input .input-container input{background-color:transparent;border:none;color:var(--modus-input-color, #252a2e);font-size:0.75rem;outline:none;padding:0 0.5rem;width:100%}.modus-date-input .input-container input.has-right-icon{padding-right:0}.modus-date-input .input-container input::placeholder{color:var(--modus-input-hint-text-color, #a3a6b1)}.modus-date-input .input-container .icons{align-items:center;background-color:var(--modus-input-bg, #fff);border-bottom-right-radius:4px;border-top-right-radius:4px;display:flex;font-size:1rem;height:100%;justify-content:center;width:2rem}.modus-date-input .input-container .icons svg.icon-calendar{cursor:pointer !important;padding:0 0.375rem}.modus-date-input .input-container .icons svg.icon-calendar path{fill:var(--modus-date-input-calendar-icon-color, #6a6e79)}.modus-date-input .input-container:hover{cursor:text}.modus-date-input .input-container:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container:focus-within svg.icon-calendar path{fill:var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.error svg.icon-calendar path{fill:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.valid svg.icon-calendar path{fill:var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.large{height:3rem}.modus-date-input .input-container.large input{font-size:0.875rem;padding:0 1rem}.modus-date-input .input-container:has(input[readonly]){background-color:var(--modus-input-readonly-bg, #e0e1e9);border-color:transparent}.modus-date-input .sub-text{font-size:0.75rem}.modus-date-input .sub-text:has(label){margin-top:0.25rem}.modus-date-input .sub-text .helper{color:var(--modus-input-label-color, #464b52);display:block;font-weight:600;margin:0}.modus-date-input .sub-text .error{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .sub-text .valid{color:var(--modus-input-validation-success-color, #006638)}.modus-date-input span.required{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input.large{font-size:0.875rem;height:48px}.modus-date-input.disabled{pointer-events:none}.modus-date-input.disabled .input-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}.modus-date-input.disabled .input-container svg path{fill:var(--modus-input-disabled-color, #a3a6b1)}.modus-date-input.disabled .input-container .icons{background-color:var(--modus-input-disabled-bg, #e0e1e9);cursor:default}.modus-date-input.disabled .input-container input{background-color:transparent;border-radius:0;color:var(--modus-input-disabled-color, #a3a6b1);height:100%}.modus-date-input input{background-position:right calc(0.375em + 0.1875rem) center;background-repeat:no-repeat;background-size:calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";padding-right:calc(1.5em + 0.75rem)}";
const ModusDateInputStyle0 = modusDateInputCss;

const ModusDateInput = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calendarIconClicked = createEvent(this, "calendarIconClicked", 7);
        this.dateInputBlur = createEvent(this, "dateInputBlur", 7);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.valueError = createEvent(this, "valueError", 7);
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this._dateInputId = `date-input-${Math.random().toString().slice(2, 7)}`;
        this._altFormatters = [];
        // TODO: Auto formatting for single tokens 'm' and 'd' is tricky because user can input double digits
        this.autoFormat = false;
        this.allowedCharsRegex = undefined;
        this.ariaLabel = undefined;
        this.autoFocusInput = undefined;
        this.disabled = undefined;
        this.disableValidation = undefined;
        this.errorText = undefined;
        this.internalErrorText = undefined;
        this.fillerDate = undefined;
        this.format = 'mm/dd/yyyy';
        this.altFormats = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.showCalendarIcon = undefined;
        this.size = 'medium';
        this.type = 'single';
        this.validText = undefined;
        this.min = undefined;
        this.max = undefined;
        this.value = undefined;
        this._dateDisplay = undefined;
    }
    handleFillerDateChange(val) {
        this._formatter = new DateInputFormatter(val, this.format);
    }
    handleFormatChange(val) {
        this._formatter = new DateInputFormatter(this.fillerDate, val);
        this.handleValueChange(this.value);
    }
    handleAltFormatsChange(altFormats) {
        if (!altFormats) {
            return;
        }
        this._altFormatters = altFormats
            .split('|')
            .map((format) => format.trim())
            .filter(Boolean)
            .map((format) => new DateInputFormatter(this.fillerDate, format));
    }
    handleValueChange(val) {
        if (!this._isEditing) {
            this._dateDisplay = this._formatter.formatDisplayString(val);
        }
        this.valueChange.emit({
            value: val,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    componentWillLoad() {
        this.handleFormatChange(this.format);
        this.handleAltFormatsChange(this.altFormats);
        this._dateDisplay = this._formatter.formatDisplayString(this.value);
        this.setDefaultAllowedKeysRegex(this.autoFormat);
    }
    /** Methods */
    /** Focus the input. */
    async focusInput() {
        this._dateInput.focus();
    }
    /** Validate the input. */
    async validate() {
        this.validateInput(this._dateDisplay);
    }
    /** Handlers */
    handleCalendarClick() {
        this.calendarIconClicked.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleDefaultKeyDown(e, callback) {
        const code = e.code.toUpperCase();
        if (code === 'ENTER' || code === 'SPACE')
            callback();
    }
    handleBlur() {
        this._isEditing = false;
        this.updateDateFromAltFormats();
        this.validateInput(this._dateDisplay);
        this.dateInputBlur.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleInputKeyPress(event) {
        const keyIsValid = this.keyIsValidDateCharacter(event.key);
        if (!keyIsValid) {
            event.preventDefault();
        }
        return keyIsValid;
    }
    handleInputKeyDown(event) {
        if (event.key.toLowerCase() === 'enter') {
            this.handleBlur();
        }
    }
    handleOnInput(event) {
        var _a;
        this._isEditing = true;
        event.stopPropagation();
        event.preventDefault();
        const inputString = (_a = event.currentTarget) === null || _a === void 0 ? void 0 : _a.value;
        this._dateDisplay = inputString;
        this.value = this._formatter.parseDisplayString(inputString.trim());
    }
    // Helpers
    clearValidation() {
        this.internalErrorText = null;
    }
    /** Check if the input string matches any of the alternative formats. */
    updateDateFromAltFormats() {
        if (this.value) {
            this._dateDisplay = this._formatter.formatDisplayString(this.value);
            return;
        }
        if (!this._dateDisplay)
            return;
        const displayDate = this._dateDisplay.trim();
        // if there is no value for the default format, check the alternative formats
        for (const formatter of this._altFormatters) {
            const result = formatter.parseDisplayString(displayDate);
            if (result) {
                this._dateDisplay = this._formatter.formatDisplayString(result);
                this.value = result;
                return;
            }
        }
    }
    keyIsValidDateCharacter(key) {
        if (!this.allowedCharsRegex)
            return true;
        const dateCharacterRegex = new RegExp(this.allowedCharsRegex);
        return dateCharacterRegex.test(key);
    }
    setDefaultAllowedKeysRegex(autoFormat) {
        if (!this.allowedCharsRegex) {
            this.allowedCharsRegex = autoFormat ? /\d/gi : /.*/;
        }
    }
    validateInput(inputString) {
        if (this.disableValidation || this.errorText)
            return;
        if (!inputString) {
            if (this.required) {
                this.internalErrorText = 'Required';
                this.valueError.emit(this.internalErrorText);
            }
            else {
                this.clearValidation();
            }
        }
        else if (!this.value || !this.isValidDate(String(this.value))) {
            this.internalErrorText = 'Invalid date';
            this.valueError.emit(this.internalErrorText);
        }
        else {
            this.validateMinMax();
        }
    }
    isValidDate(dateString) {
        const date = new Date(dateString);
        return date instanceof Date && !isNaN(date.getTime()) && date.toISOString().startsWith(dateString);
    }
    validateMinMax() {
        const min = this._formatter.parseIsoToDate(this.min);
        const max = this._formatter.parseIsoToDate(this.max);
        const value = this._formatter.parseIsoToDate(this.value);
        if (min && min > value) {
            min.setUTCDate(min.getDate() - 1);
            this.internalErrorText = `Select a date after ${this._formatter.formatDisplayString(min.toISOString())}`;
            this.valueError.emit(this.internalErrorText);
        }
        else if (max && max < value) {
            max.setUTCDate(max.getDate() + 1);
            this.internalErrorText = `Select a date before ${this._formatter.formatDisplayString(max.toISOString())}`;
            this.valueError.emit(this.internalErrorText);
        }
        else {
            this.clearValidation();
        }
    }
    render() {
        var _a;
        const className = `modus-date-input ${this.disabled ? 'disabled' : ''}`;
        const displayErrorMessage = this.internalErrorText || this.errorText;
        const displayValidMessage = !displayErrorMessage && this.validText;
        return (h("div", { key: '11748c327dac4ffd55b82a860d6f4d0dee839de3', class: className }, this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this._dateInputId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null, this.helperText ? h("label", { class: "sub-text helper" }, this.helperText) : null)) : null, h("div", { key: 'ebe2014200739e3174a4f606018dbabe79fc0bac', class: `input-container ${displayErrorMessage ? 'error' : this.validText ? 'valid' : ''} ${this.classBySize.get(this.size)}`, part: `input-container ${displayErrorMessage ? 'error' : this.validText ? 'valid' : ''}` }, h("input", { key: 'dde7167d78b896a0acb6fe86b57c97ee739fb892', "aria-invalid": !!displayErrorMessage, "aria-label": this.ariaLabel || undefined, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString(), autofocus: this.autoFocusInput, class: { 'has-right-icon': this.showCalendarIcon }, disabled: this.disabled, id: this._dateInputId, onBlur: () => this.handleBlur(), onInput: (event) => this.handleOnInput(event), onKeyPress: (e) => this.handleInputKeyPress(e), onKeyDown: (e) => this.handleInputKeyDown(e), placeholder: this.placeholder, readonly: this.readOnly, ref: (el) => (this._dateInput = el), tabIndex: 0, type: "text", value: this._dateDisplay }), this.showCalendarIcon && (h("span", { class: "icons", tabIndex: 0, onKeyDown: (e) => this.handleDefaultKeyDown(e, () => this.handleCalendarClick()), onClick: () => this.handleCalendarClick(), role: "button", "aria-label": "Open calendar" }, h(ModusIconMap, { icon: "calendar", size: "16" })))), h("div", { key: '18caf62b1f4ccd23bd06b5e25cb0a4b4af0681d5', class: "sub-text", part: "sub-text" }, displayErrorMessage ? (h("label", { class: "error" }, displayErrorMessage)) : displayValidMessage ? (h("label", { class: "valid" }, this.validText)) : null)));
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "fillerDate": ["handleFillerDateChange"],
        "format": ["handleFormatChange"],
        "altFormats": ["handleAltFormatsChange"],
        "value": ["handleValueChange"]
    }; }
};
ModusDateInput.style = ModusDateInputStyle0;

const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
class ModusDatePickerCalendar {
    constructor(calendar) {
        if (calendar) {
            this.gotoDate(calendar.currentDate.getFullYear(), calendar.currentDate.getMonth());
        }
        else {
            const today = new Date();
            this.gotoDate(today.getFullYear(), today.getMonth());
        }
    }
    get year() {
        return this.currentDate.getFullYear().toString();
    }
    get month() {
        return MONTH_NAMES[this.currentDate.getMonth()];
    }
    get selectedYear() {
        return this.currentDate.getFullYear();
    }
    get selectedMonth() {
        return this.currentDate.getMonth();
    }
    get dates() {
        return this.currentMonthDates;
    }
    addMonthOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear(), this.currentDate.getMonth() + offset);
        return this;
    }
    addYearOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear() + offset, this.currentDate.getMonth());
        return this;
    }
    gotoDate(year, month) {
        this.currentDate = new Date(year, month, 1);
        this.calculateDates();
    }
    getDaysOfWeek(locale, firstDayOfWeek = 0) {
        /**
         * Nov 1st, 2020 starts on a Sunday,
         * assumes weeks start on Sunday,
         * but is configurable via `firstDayOfWeek`.
         */
        const intl = new Intl.DateTimeFormat(locale, { weekday: 'short' });
        const startDate = new Date('11/01/2020');
        const daysOfWeek = [];
        /**
         * For each day of the week,
         * get the day name.
         */
        for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
            const currentDate = new Date(startDate);
            currentDate.setDate(currentDate.getDate() + i);
            const d = intl.format(currentDate);
            daysOfWeek.push(d.toUpperCase().startsWith('SA') ? d : d.slice(0, 2));
        }
        return daysOfWeek;
    }
    calculateDates() {
        const dates = [];
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        const date = new Date(year, month, 1);
        while (date.getMonth() === month) {
            dates.push(new Date(date));
            date.setDate(date.getDate() + 1);
        }
        this.currentMonthDates = dates;
    }
}

class ModusDatePickerState {
    constructor(el) {
        var _a;
        this.isOpen = false;
        this.element = el;
        this.element.showCalendarIcon = ((_a = this.element.showCalendarIcon) === null || _a === void 0 ? void 0 : _a.toString().toUpperCase()) !== 'FALSE';
        this.max = this.parseDate(this.element.max);
        this.min = this.parseDate(this.element.min);
        this.refresh();
    }
    getDate() {
        return this.date;
    }
    getMaxDateAllowed() {
        return this.max;
    }
    getMinDateAllowed() {
        return this.min;
    }
    setDate(val) {
        // Converting to ISO8601 'yyyy-mm-dd' format
        if (Number(val)) {
            const year = val.getFullYear();
            const month = (val.getMonth() + 1).toString().padStart(2, '0'); // Zero based number system for months
            const date = val.getDate().toString().padStart(2, '0');
            this.element.value = `${year}-${month}-${date}`;
            this.element.errorText = null;
            this.element.focusInput();
            this.date = val;
        }
    }
    setError(message = null) {
        this.element.errorText = message;
    }
    validateInput() {
        this.element.validate();
    }
    refresh() {
        this.date = this.parseDate(this.element.value);
    }
    parseDate(date) {
        if (!date) {
            return null;
        }
        // Note: Modus Date Input component's value is always in 'yyyy-mm-dd' format
        const dateISORegex = new RegExp(ISO_DATE_FORMAT);
        const parse = dateISORegex.exec(date);
        if (parse) {
            // first element returns the whole date string
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, // Zero based number system for months
            parseFloat(parse[2]));
        }
        return null;
    }
    toggleCalendar(val = null) {
        this.isOpen = val !== null ? val : !this.isOpen;
    }
    isCalendarOpen() {
        return this.isOpen;
    }
}

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
const yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ['left', 'right'];
const rlPlacement = ['right', 'left'];
const tbPlacement = ['top', 'bottom'];
const btPlacement = ['bottom', 'top'];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case 'left':
    case 'right':
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow ||
          // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            // Try next placement and re-run the lifecycle.
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = min(...rects.map(rect => rect.left));
  const minY = min(...rects.map(rect => rect.top));
  const maxX = max(...rects.map(rect => rect.right));
  const maxY = max(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

const originSides = /*#__PURE__*/new Set(['left', 'top']);

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [':popover-open', ':modal'];
function isTopLayer(element) {
  return topLayerSelectors.some(selector => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];
const willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];
const containValues = ['paint', 'layout', 'strict', 'content'];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
const lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

function getCssDimensions(element) {
  const css = getComputedStyle(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

const absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);

  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
  // Firefox with layout.scrollbar.side = 3 in about:config to test this.
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return getComputedStyle(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return getComputedStyle(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        // It's possible that even though the ratio is reported as 1, the
        // element is not actually fully within the IntersectionObserver's root
        // area anymore. This can happen under performance constraints. This may
        // be a bug in the browser's IntersectionObserver implementation. To
        // work around this, we compare the element's bounding rect now with
        // what it was at the time we created the IntersectionObserver. If they
        // are not equal then the element moved, so we refresh.
        refresh();
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
offset;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = autoPlacement$1;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = shift$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = flip$1;

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
size;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
hide;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
arrow;

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
inline;

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = limitShift$1;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

const modusDatePickerCss = ".modus-date-picker{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-picker .date-inputs{display:grid;grid-gap:0.5rem;grid-template-columns:auto auto}.modus-date-picker button{background:0;border:0;cursor:pointer;display:inline-flex;margin:0;padding:0}.modus-date-picker button.disabled{cursor:default}.modus-date-picker .label-container{display:flex}.modus-date-picker .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;margin-bottom:0.25rem}.modus-date-picker .input-container input{font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"}.modus-date-picker .calendar-container{background-color:var(--modus-date-picker-calendar-body-bg, #fff);border-radius:4px;box-shadow:0 0 4px rgba(0, 0, 0, 0.1607843137);display:flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";left:0;position:absolute;top:0;width:max-content;z-index:1}.modus-date-picker .calendar-container[data-popper-reference-hidden]{pointer-events:none;visibility:hidden}.modus-date-picker .calendar-container .calendar-header{align-items:center;background-color:var(--modus-date-picker-calendar-header-bg, #0063a3);border-top-left-radius:4px;border-top-right-radius:4px;color:var(--modus-date-picker-calendar-header-color, #fff);display:flex;font:normal normal 600 16px/22px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";height:40px;justify-content:space-around;letter-spacing:0;opacity:1;text-align:center;width:100%}.modus-date-picker .calendar-container .calendar-header svg path{fill:var(--modus-date-picker-calendar-header-color, #fff)}.modus-date-picker .calendar-container .calendar-header .title{align-items:center;display:inline-flex;justify-content:center}.modus-date-picker .calendar-container .calendar-header .calendar-title:focus+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:hover+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:active+.year-icons,.modus-date-picker .calendar-container .calendar-header .year-icons:hover,.modus-date-picker .calendar-container .calendar-header .year-icons:focus,.modus-date-picker .calendar-container .calendar-header .year-icons:focus-within{opacity:1 !important}.modus-date-picker .calendar-container .calendar-header .year-icons{display:inline-flex;flex-direction:column;margin-left:0.5rem;opacity:0}.modus-date-picker .calendar-container .calendar-header .year-icons button:active{opacity:0.5}.modus-date-picker .calendar-container .calendar-body{align-items:center;display:flex;flex-direction:column;font-size:0.875rem;justify-content:center;padding:1rem}.modus-date-picker .calendar-container .calendar-body .grid{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}.modus-date-picker .calendar-container .calendar-body .grid .grid-item{align-items:center;display:flex;height:32px;justify-content:center;width:32px}.modus-date-picker .calendar-container .calendar-body .out-of-range-notification{margin-top:0.6rem;text-align:center}.modus-date-picker .calendar-container .calendar-body .goto-available-dates{color:var(--modus-link-color, #217cbb);cursor:pointer}.modus-date-picker .calendar-container .calendar-body .calendar-days-week{color:var(--modus-date-picker-calendar-day-week-color, #363545);font:normal normal bold 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day{color:var(--modus-date-picker-calendar-day-color, #252a2e);font:normal normal normal 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day:hover{background:var(--modus-date-picker-calendar-day-hover-bg, #e0e1e9) 0% 0% no-repeat padding-box !important;border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.current-day{background:var(--modus-date-picker-calendar-body-bg, #fff) 0% 0% no-repeat padding-box;border:2px solid var(--modus-date-picker-calendar-day-current-border-color, #217cbb);border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected{background:var(--modus-date-picker-calendar-day-selected-bg, #217cbb) 0% 0% no-repeat padding-box;border-radius:16px;color:var(--modus-date-picker-calendar-day-selected-color, #fff)}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after,.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{background-color:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9);content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after{border-radius:50% 0 0 50% !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{border-radius:0 50% 50% 0 !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.disabled{opacity:var(--modus-date-picker-calendar-day-disabled-opacity, 0.3);pointer-events:none}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected:hover::before,.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected.current-day::before{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box;content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-month{position:absolute}.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .start::after,.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .end::after{opacity:0}.modus-date-picker .calendar-container .calendar-body .calendar-month-container{display:flex;height:180px;justify-content:center;position:relative}";
const ModusDatePickerStyle0 = modusDatePickerCss;

const ModusDatePicker = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this._dateInputs = {};
        this._locale = 'default';
        this.cleanupPopover = undefined;
        this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
        this.label = undefined;
        this.position = 'bottom-start';
        this.isDateEnabled = undefined;
        this._forceUpdate = {};
        this._showCalendar = false;
        this._showYearArrows = false;
    }
    get _currentInput() {
        return Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
    componentWillLoad() {
        this._calendar = new ModusDatePickerCalendar();
    }
    componentDidUpdate() {
        var _a;
        if (this._showCalendar) {
            this.configureCalendarPopover();
        }
        else {
            (_a = this.cleanupPopover) === null || _a === void 0 ? void 0 : _a.call(this);
        }
    }
    disconnectedCallback() {
        var _a;
        (_a = this.cleanupPopover) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    configureCalendarPopover() {
        const referenceElement = this.element.shadowRoot.querySelector('.calendar');
        const floatingElement = this.element.shadowRoot.querySelector('.calendar-container');
        this.cleanupPopover = autoUpdate(referenceElement, floatingElement, () => {
            const options = {};
            const middleware = [];
            // The preventOverflow modifier from Popper is now called shift.
            // This is because technically many modifiers in Popper 2 prevented overflow,
            // which does not describe what it is actually doing unlike shift. (https://floating-ui.com/docs/migration#configure-middleware)
            middleware.push(shift({ limiter: limitShift() }));
            if (this.position.includes('auto')) {
                const autoPlacementOptions = {};
                if (this.position.includes('-')) {
                    const [, alignment] = this.position.split('-');
                    autoPlacementOptions.alignment = alignment;
                }
                middleware.push(autoPlacement(autoPlacementOptions));
            }
            else {
                options.placement = this.position;
                middleware.push(flip());
            }
            if (this.position === 'auto') {
                options.strategy = 'fixed';
            }
            options.middleware = middleware;
            computePosition(referenceElement, floatingElement, options).then(({ x, y }) => {
                Object.assign(floatingElement.style, {
                    left: `${x}px`,
                    top: `${y}px`,
                });
            });
        });
    }
    /** Handlers */
    handleCalendarIconClick(event) {
        const { type } = event.detail;
        Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
        this.toggleCalendar();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleClickOutside(event) {
        const path = event.composedPath();
        const insideComponent = path.includes(this.element);
        if (insideComponent || event.defaultPrevented) {
            return;
        }
        // Collapse when clicked outside
        this.toggleCalendar(false);
    }
    handleDateInputValue(event) {
        const { type } = event.detail;
        if (!this._dateInputs[type])
            return;
        this._dateInputs[type].refresh();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleDateInputBlur() {
        var _a, _b;
        this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
    }
    handleSlotChange() {
        const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
        dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
            this._dateInputs[d.type] = new ModusDatePickerState(d);
        });
    }
    /** Helpers */
    addMonthOffset(offset) {
        this._calendar.addMonthOffset(offset);
        this.forceUpdate();
    }
    addYearOffset(offset) {
        this._calendar.addYearOffset(offset);
        this.forceUpdate();
    }
    applyDateRangeRules(startDate, endDate) {
        if (!startDate || !endDate) {
            return;
        }
        if (this.isInvalidDateRange(startDate, endDate)) {
            this._dateInputs['start'].setError('Invalid date range');
            this._dateInputs['end'].setError();
        }
        else {
            this._dateInputs['start'].setError('');
            this._dateInputs['end'].setError('');
            this._dateInputs['start'].validateInput();
            this._dateInputs['end'].validateInput();
        }
    }
    compare(date1, date2) {
        if (!date1 && !date2) {
            return 0;
        }
        else if (!date1 && date2) {
            return -1;
        }
        else if (date1 && !date2) {
            return 1;
        }
        let delta;
        delta = date1.getFullYear() - date2.getFullYear();
        if (delta !== 0) {
            return delta;
        }
        delta = date1.getMonth() - date2.getMonth();
        if (delta !== 0) {
            return delta;
        }
        return date1.getDate() - date2.getDate();
    }
    forceUpdate() {
        this._forceUpdate = Object.assign({}, this._forceUpdate);
    }
    findDatePositionsInARange(date, startDate, endDate) {
        return {
            start: startDate && this.compare(date, startDate) === 0,
            end: endDate && this.compare(date, endDate) === 0,
            'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
        };
    }
    gotoDateBeingPicked(pickedDate) {
        if (!this._showCalendar) {
            return;
        }
        const date = pickedDate || new Date();
        this._calendar.gotoDate(date.getFullYear(), date.getMonth());
    }
    goToNearestBoundaryDate(date) {
        var _a, _b;
        const minDate = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMinDateAllowed();
        const maxDate = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMaxDateAllowed();
        const targetDate = this.compare(date, minDate) < 0 ? minDate : maxDate;
        this.gotoDateBeingPicked(targetDate);
        this.forceUpdate();
    }
    pickCalendarDate(date) {
        this._currentInput.setDate(date);
        this.toggleCalendar(false);
    }
    showYearChange(show = true) {
        this._showYearArrows = show;
    }
    isWithinCurrentMinMax(date) {
        var _a, _b;
        const max = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMaxDateAllowed();
        const min = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMinDateAllowed();
        if (!date) {
            return false;
        }
        if (min && this.compare(date, min) < 0) {
            return false;
        }
        if (max && this.compare(date, max) > 0) {
            return false;
        }
        return true;
    }
    toggleCalendar(val = null) {
        if (val !== null) {
            this._showCalendar = val;
            if (!this._showCalendar) {
                Object.keys(this._dateInputs || {}).forEach((d) => {
                    this._dateInputs[d].toggleCalendar(false);
                });
            }
        }
        else {
            this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
        }
    }
    renderCalendarBody() {
        var _a, _b, _c, _d;
        const today = new Date();
        const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
        const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
        const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
        // Get day of the week and prepare blank cells to render the calendar dates properly
        const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
        const blankDatesArr = new Array(firstDay).fill(0);
        return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
            return h("div", { class: "grid-item" }, d);
        })), h("div", { class: "calendar-month-container" }, h("div", { class: {
                'calendar-month grid': true,
                'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
            } }, blankDatesArr &&
            blankDatesArr.length > 0 &&
            blankDatesArr.map(() => {
                return (h("button", { class: {
                        'calendar-day grid-item': false,
                        disabled: true,
                    }, disabled: true, tabIndex: -1 }, "\u00A0"));
            }), this._calendar.dates.map((date, index) => {
            if (!date) {
                return null;
            }
            const positions = this.findDatePositionsInARange(date, startDate, endDate);
            const isStartDate = positions['start'];
            const isEndDate = positions['end'];
            const isToday = this.compare(date, today) === 0;
            const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
            const isSelected = isStartDate || isEndDate || isSingleDateSelected;
            const isInRange = !isSelected ? positions['in-range'] : false;
            const isDateOutOfMaxMinRange = !this.isWithinCurrentMinMax(date);
            const isDateEnabled = this.isDateEnabled ? this.isDateEnabled(date.toISOString()) : true;
            // Only for the last date in the calendar
            const onBlurEvent = index === this._calendar.dates.length - 1
                ? {
                    onBlur: () => {
                        this.toggleCalendar(false);
                    },
                }
                : {};
            const buttonDisabled = isDateOutOfMaxMinRange || !isDateEnabled;
            return (h("button", Object.assign({ class: {
                    'calendar-day grid-item': true,
                    selected: isSelected,
                    disabled: buttonDisabled,
                    start: isStartDate && !isEndDate,
                    end: isEndDate && !isStartDate,
                    'current-day': isToday,
                    'range-selected': isInRange,
                }, disabled: buttonDisabled, tabIndex: 0, type: "button", "aria-current": isSelected ? 'date' : undefined, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
        }))), !this.isWithinCurrentMinMax(this._currentInput.getDate()) && (h("div", { class: "out-of-range-notification" }, h("div", null, "The selected date is not available"), h("span", { class: "goto-available-dates", onClick: () => this.goToNearestBoundaryDate(this._currentInput.getDate()) }, "Go to available dates")))));
    }
    renderCalendarHeader() {
        var _a, _b;
        return (h("div", { class: "calendar-header" }, h("button", { type: "button", "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(ModusIconMap, { icon: "chevron_left_bold" })), h("div", { class: "title" }, h("div", { class: "calendar-title", role: "heading" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { type: "button", tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(ModusIconMap, { icon: "caret_up", size: "16" })), h("button", { type: "button", tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(ModusIconMap, { size: "16", icon: "caret_down" })))), h("button", { type: "button", tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(ModusIconMap, { icon: "chevron_right_bold" }))));
    }
    render() {
        return (h("div", { key: '296f45926a5e4e7faf415fafa9ad149c56661f9e', class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { key: '7ac0f29be1e1ad25531a24714dd520050c7d4604', class: "date-inputs", part: "date-inputs" }, h("slot", { key: 'b40cf940b60aa59f452b2da88e07bd8ebb5d418b', onSlotchange: () => this.handleSlotChange() })), h("div", { key: 'fc6cb1a09499860ae721fc96b757fb67f67a4fc7', class: "calendar", part: "calendar", style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
    }
    get element() { return getElement(this); }
};
ModusDatePicker.style = ModusDatePickerStyle0;

const modusNumberInputCss = ".modus-number-input{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";width:100%}.modus-number-input label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.modus-number-input label span{color:var(--modus-input-border-color, #6a6e79);margin:0.25rem}.modus-number-input .label-container{align-items:baseline;display:inline-block;margin-bottom:0.25rem}.modus-number-input .label-container .required{color:var(--modus-input-validation-error-color, #da212c);margin-left:0.25rem}.modus-number-input .input-container{align-items:center;background-color:var(--modus-input-bg, #fff);border:0.0625rem solid var(--modus-input-border-color, #6a6e79);border-radius:4px;display:flex;flex-direction:row;height:32px}.modus-number-input .input-container input{background-color:transparent;border:none;color:var(--modus-input-color, #252a2e);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";outline:0;padding:0 0.5rem;width:100%}.modus-number-input .input-container input.text-align-right{padding-right:0;text-align:right}.modus-number-input .input-container input::placeholder{color:var(--modus-input-hint-text-color, #a3a6b1)}.modus-number-input .input-container:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}.modus-number-input .input-container.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}.modus-number-input .input-container.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}.modus-number-input .input-container.large{height:48px}.modus-number-input .input-container.large input{font-size:0.875rem;height:47px;padding:0 1rem}.modus-number-input .input-container:has(input[readonly]){background-color:var(--modus-input-readonly-bg, #e0e1e9);border-color:var(--modus-input-disabled-bottom-line-color, #a3a6b1)}.modus-number-input .sub-text{font-size:0.75rem;margin-top:0.25rem}.modus-number-input .sub-text.helper{color:var(--modus-input-label-color, #464b52);display:block;font-weight:600;margin:0}.modus-number-input .sub-text.error{color:var(--modus-input-validation-error-color, #da212c)}.modus-number-input .sub-text.valid{color:var(--modus-input-validation-success-color, #006638)}.modus-number-input.disabled{pointer-events:none}.modus-number-input.disabled .input-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}.modus-number-input.disabled .input-container input{background-color:transparent;color:var(--modus-input-disabled-color, #a3a6b1)}";
const ModusNumberInputStyle0 = modusNumberInputCss;

const ModusNumberInput = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.inputId = generateElementId() + '_number-input';
        this.inputFocused = false;
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.handleOnBlur = () => {
            if (this.currency || this.locale) {
                this.inputFocused = false;
                this.formattedValue = this.getFormattedValue();
                this.input.type = 'text';
                this.input.value = this.formattedValue;
            }
        };
        this.handleOnFocus = () => {
            if (this.currency || this.locale) {
                this.inputFocused = true;
                this.input.value = this.value !== undefined ? this.value : '';
                this.input.type = 'number';
            }
        };
        this.formattedValue = this.getFormattedValue();
        this.ariaLabel = undefined;
        this.currency = undefined;
        this.disabled = undefined;
        this.errorText = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.locale = undefined;
        this.maxValue = undefined;
        this.minValue = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.size = 'medium';
        this.step = undefined;
        this.textAlign = 'left';
        this.validText = undefined;
        this.value = undefined;
    }
    handleOnInput() {
        this.value = this.input.value;
        this.valueChange.emit(this.value);
    }
    /** Focus the input. */
    async focusInput() {
        this.input.focus();
    }
    watchValue(newValue, oldValue) {
        if (isNaN(+newValue)) {
            this.value = oldValue;
        }
        else {
            this.value = newValue;
        }
        // Only updated when the input value is changed programatically by the consumer
        if ((this.currency || this.locale) && !this.inputFocused) {
            this.formattedValue = this.getFormattedValue();
        }
    }
    getFormattedValue() {
        const numericValue = parseFloat((this.value !== undefined ? this.value : '').replace(/[^0-9.-]+/g, ''));
        if (this === null || this === void 0 ? void 0 : this.value) {
            let formattedValue;
            if (this.currency && this.locale) {
                formattedValue = new Intl.NumberFormat(this.locale, {
                    style: 'currency',
                    currency: this.currency,
                }).format(numericValue);
            }
            else if (this.currency) {
                formattedValue = new Intl.NumberFormat(undefined, {
                    style: 'currency',
                    currency: this.currency,
                }).format(numericValue);
            }
            else if (this.locale) {
                formattedValue = new Intl.NumberFormat(this.locale).format(numericValue);
            }
            else {
                formattedValue = numericValue.toString();
            }
            return formattedValue;
        }
        return '';
    }
    render() {
        var _a;
        const textAlignClassName = `text-align-${this.textAlign}`;
        const buildContainerClassNames = () => {
            const classNames = [];
            classNames.push('modus-number-input');
            if (this.disabled) {
                classNames.push('disabled');
            }
            return classNames.join(' ');
        };
        const buildInputContainerClassNames = () => {
            const classNames = [];
            classNames.push('input-container');
            classNames.push(this.classBySize.get(this.size));
            if (this.errorText) {
                classNames.push('error');
            }
            if (this.validText) {
                classNames.push('valid');
            }
            return classNames.join(' ');
        };
        const inputType = this.currency || this.locale ? 'text' : 'number';
        const inputAriaProps = inputType === 'number'
            ? {
                ariaValuemax: this.maxValue !== undefined ? this.maxValue.toString() : undefined,
                ariaValuemin: this.minValue !== undefined ? this.minValue.toString() : undefined,
                ariaValuenow: this.value ? parseFloat(this.value).toString() : undefined,
            }
            : {};
        return (h("div", { class: buildContainerClassNames() }, this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this.inputId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null, this.helperText ? h("label", { class: "sub-text helper" }, this.helperText) : null)) : null, h("div", { class: buildInputContainerClassNames(), part: "input-container" }, h("input", Object.assign({ id: this.inputId, "aria-label": this.ariaLabel, "aria-invalid": !!this.errorText, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString(), class: textAlignClassName, disabled: this.disabled, max: this.maxValue, min: this.minValue, onInput: () => this.handleOnInput(), onFocusin: this.handleOnFocus, onBlur: this.handleOnBlur, placeholder: this.placeholder, readonly: this.readOnly, ref: (el) => (this.input = el), step: this.step, tabIndex: 0, type: inputType, value: inputType === 'text' ? this.formattedValue : this.value }, inputAriaProps))), this.errorText ? (h("label", { class: "sub-text error" }, this.errorText)) : this.validText ? (h("label", { class: "sub-text valid" }, this.validText)) : null));
    }
    static get watchers() { return {
        "value": ["watchValue"]
    }; }
};
ModusNumberInput.style = ModusNumberInputStyle0;

const modusSelectCss = ":host{color:var(--modus-input-color, #252a2e);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative}:host .label-container{align-items:baseline;display:flex}:host .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin:0 0.25rem 0.25rem 0}:host .label-container .required{color:var(--modus-input-validation-error-color, #da212c)}:host .input-container{position:relative}:host .input-container:hover{cursor:pointer}:host .input-container select{align-items:center;appearance:none;background-color:var(--modus-input-bg, #fff);background-image:var(--modus-select-bg-image, url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"%3e%3cpath fill=\"none\" stroke=\"%231b1a26\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m2 5 6 6 6-6\"/%3e%3c/svg>'));background-position:right 0.5rem center;background-repeat:no-repeat;background-size:16px 12px;border:solid 0.0625rem var(--modus-input-border-color, #6a6e79);border-radius:4px;color:var(--modus-input-color, #464b52);display:flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:0.75rem;height:2rem;padding-left:0.625rem;padding-right:2rem;position:relative;width:100%}:host .input-container select.disabled{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}:host .input-container select:hover{cursor:pointer}:host .input-container select:focus{outline:none}:host .input-container select:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}:host .input-container select.large{font-size:0.875rem;height:3rem}:host .input-container select.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}:host .input-container select.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}:host .input-container select.fit-parent{border:none;height:inherit}:host .sub-text{font-size:0.75rem;margin-top:0.25rem}:host .sub-text.helper{color:var(--modus-input-label-color, #464b52)}:host .sub-text.error{color:var(--modus-input-validation-error-color, #da212c)}:host .sub-text.valid{color:var(--modus-input-validation-success-color, #006638)}";
const ModusSelectStyle0 = modusSelectCss;

const ModusSelect = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.inputBlur = createEvent(this, "inputBlur", 7);
        this.selectId = generateElementId() + '_select';
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.ariaLabel = undefined;
        this.disabled = undefined;
        this.errorText = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.options = [];
        this.optionsDisplayProp = undefined;
        this.placeholder = 'Please Select';
        this.required = undefined;
        this.size = 'medium';
        this.validText = undefined;
        this.value = undefined;
        this.internalValue = undefined;
        this.optionIdMap = new Map();
    }
    handleValueChange(newValue) {
        this.internalValue = newValue;
    }
    /** Focus the input. */
    async focusInput() {
        this.selectInput.focus();
    }
    connectedCallback() {
        this.internalValue = this.value;
    }
    handleOptionSelect(option) {
        this.valueChange.emit(option);
    }
    handleSelectChange(event) {
        const target = event.target;
        const selectedId = target.value;
        const option = this.optionIdMap.get(selectedId);
        this.handleOptionSelect(option);
    }
    renderSubText() {
        if (this.errorText) {
            return h("label", { class: "sub-text error" }, this.errorText);
        }
        else if (this.validText) {
            return h("label", { class: "sub-text valid" }, this.validText);
        }
        else if (this.helperText) {
            return h("label", { class: "sub-text helper" }, this.helperText);
        }
        return null;
    }
    renderLabel() {
        return this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this.selectId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null)) : null;
    }
    renderOptions() {
        var _a;
        return (_a = this.options) === null || _a === void 0 ? void 0 : _a.map((option) => {
            const optionId = createGuid();
            this.optionIdMap.set(optionId, option);
            return (h("option", { value: optionId, key: optionId, selected: option[this.optionsDisplayProp] === this.internalValue }, option[this.optionsDisplayProp]));
        });
    }
    render() {
        var _a;
        const selectClass = `${this.classBySize.get(this.size)} ${this.errorText ? 'error' : this.validText ? 'valid' : this.disabled ? 'disabled' : ''}`;
        return (h("div", { key: 'ab38018e065d411d799c8c79d517ed0342a5fae8', class: this.disabled ? 'disabled' : undefined }, this.renderLabel(), h("span", { key: 'ad4acad2bfd52ac2ae4e9408d70d9a8e8a92d121', class: "input-container" }, h("select", { key: 'e9c56542b567e6a638c00854ac8b7275a56b2256', part: "input", ref: (el) => (this.selectInput = el), disabled: this.disabled, id: this.selectId, class: selectClass, "aria-label": this.ariaLabel || undefined, onBlur: (e) => this.inputBlur.emit(e), onChange: (event) => {
                this.handleSelectChange(event);
            }, "aria-invalid": !!this.errorText, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString() }, h("option", { key: '0ae21d39e25fbe3cadc84a25705744a46a6b9a85', value: "", disabled: true, selected: true }, this.placeholder), this.renderOptions()), this.renderSubText())));
    }
    static get watchers() { return {
        "value": ["handleValueChange"]
    }; }
};
ModusSelect.style = ModusSelectStyle0;

const modusTableCellEditorCss = ":host{--modus-autocomplete-border:none;--modus-autocomplete-border-active:none;--modus-autocomplete-font-size:14px;--modus-input-border-color:none}.editor::part(input-container),.editor::part(input){height:2.9375rem !important}table.density-comfortable .editor::part(input-container),table.density-comfortable .editor::part(input){height:1.75rem !important}table.density-compact .editor::part(input-container),table.density-compact .editor::part(input){height:1.25rem !important}.autocomplete-container{margin-left:4px;margin-top:5px}.editor::part(sub-text){display:none}.date-picker-container::part(date-inputs){align-items:center;display:flex;justify-content:center}.date-picker-container::part(calendar){z-index:99}.editor::part(input-container){border:2px solid var(--modus-input-border-active-color, #217cbb);border-radius:unset;z-index:99}.editor::part(input-container error){border:2px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;z-index:99}.error .editor::part(input-container){border:1px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;box-shadow:2px solid var(--modus-input-border-active-color, #da212c);z-index:99}.error-tooltip{background-color:var(--modus-input-validation-error-color, #da212c);border-radius:2px;color:#fff;display:none;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:12px;font-weight:600;letter-spacing:0.005em;line-height:15px;max-width:200px;padding:5px 8px;text-align:left;word-wrap:break-word;z-index:10}";
const ModusTableCellEditorStyle0 = modusTableCellEditorCss;

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModusTableCellEditor = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.handleBlur = () => {
            this.valueChange(this.editedValue);
        };
        this.handleKeyDown = (e) => {
            this.keyDown(e, this.editedValue);
        };
        this.getDefaultProps = (ariaLabel) => ({
            'aria-label': ariaLabel,
            class: 'editor',
            ref: (ref) => (this.inputElement = ref),
        });
        this.args = undefined;
        this.dataType = undefined;
        this.value = undefined;
        this.type = undefined;
        this.valueChange = undefined;
        this.keyDown = undefined;
        this.inputValueChangeHandler = undefined;
    }
    connectedCallback() {
        this.editedValue = this.value;
    }
    componentDidLoad() {
        if (this.inputElement['focusInput']) {
            this.inputElement['focusInput']();
        }
    }
    handleDocumentClick(event) {
        if (this.type != 'date') {
            return;
        }
        const target = event.target;
        if (!this.inputElement.contains(target)) {
            this.handleBlur();
        }
    }
    renderNumberInput() {
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("modus-number-input", Object.assign({}, this.getDefaultProps('Number input'), { value: this.value, textAlign: "right", size: "large", onBlur: this.handleBlur, onValueChange: (e) => (this.editedValue = e.detail), onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown) })));
    }
    renderTextInput() {
        return (h("modus-text-input", Object.assign({}, this.getDefaultProps('Text input'), { value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail;
                this.inputValueChangeHandler(e.detail);
            }, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, autoFocusInput: true, size: "large" })));
    }
    renderSelectInput() {
        const valueKey = 'display';
        const args = this.args;
        const options = (args === null || args === void 0 ? void 0 : args.options) || [];
        const optionsDisplayProp = (args === null || args === void 0 ? void 0 : args.optionsDisplayProp) || valueKey;
        const placeholder = args === null || args === void 0 ? void 0 : args.placeholder;
        const selectedOption = options.find((option) => option[optionsDisplayProp] === this.value);
        function handleEnter(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_ENTER) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", null, h("modus-select", Object.assign({}, this.getDefaultProps('Select input'), { value: selectedOption, "options-display-prop": optionsDisplayProp, size: "large", options: options, placeholder: placeholder, onInputBlur: this.handleBlur, onKeyDown: (e) => handleEnter(e, this.handleKeyDown), onValueChange: (e) => {
                const detail = e.detail;
                if (this.dataType === 'badge') {
                    const { display } = detail, restProps = __rest(detail, ["display"]);
                    this.editedValue = Object.assign(Object.assign({}, restProps), { text: display });
                }
                else if (this.dataType === 'link') {
                    this.editedValue = detail;
                }
                else {
                    this.editedValue = detail[valueKey];
                }
            } }))));
    }
    renderDateInput() {
        var _a;
        const valueKey = 'value';
        const format = (_a = this.args) === null || _a === void 0 ? void 0 : _a.format;
        return (h("modus-date-picker", { onBlur: this.handleBlur, position: "auto", onClick: (e) => e.stopPropagation(), class: "date-picker-container" }, h("modus-date-input", Object.assign({}, this.getDefaultProps('Date input'), { format: format, size: "large", "show-calendar-icon": "true", value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail[valueKey];
            } }))));
    }
    renderAutocompleteInput() {
        var _a, _b;
        const args = this.args;
        let options = [];
        let selectedOption = '';
        if (this.dataType === 'badge') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.text);
            selectedOption = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.text) || '';
        }
        else if (this.dataType === 'link') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.display);
            selectedOption = ((_b = this.value) === null || _b === void 0 ? void 0 : _b.display) || '';
        }
        else {
            options = ((args === null || args === void 0 ? void 0 : args.options) || []);
            selectedOption = this.editedValue;
        }
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", { class: "autocomplete-container" }, h("modus-autocomplete", Object.assign({}, this.getDefaultProps('Autocomplete input'), { "include-search-icon": "false", size: "medium", ref: (el) => (this.inputElement = el), options: options, onBlur: this.handleBlur, onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown), filterOptions: args.filterOptions
                ? (...props) => {
                    if (this.inputElement && (args === null || args === void 0 ? void 0 : args.filterOptions)) {
                        this.inputElement.loading = true;
                        return args === null || args === void 0 ? void 0 : args.filterOptions(...props).finally(() => {
                            this.inputElement.loading = false;
                        });
                    }
                }
                : undefined, onOptionSelected: (e) => {
                const selectedDetail = e.detail;
                if (this.dataType === 'badge') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.text === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else if (this.dataType === 'link') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.display === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else {
                    this.editedValue = selectedDetail;
                }
            }, value: selectedOption }))));
    }
    renderEditor() {
        switch (this.type) {
            case CELL_EDIT_TYPE_SELECT:
                return this.renderSelectInput();
            case CELL_EDIT_TYPE_AUTOCOMPLETE:
                return this.renderAutocompleteInput();
            case CELL_EDIT_TYPE_DATE:
                return this.renderDateInput();
            case CELL_EDIT_TYPE_INT:
                return this.renderNumberInput();
            case CELL_EDIT_TYPE_TEXT:
            default:
                return this.renderTextInput();
        }
    }
    render() {
        return h(Host, { key: '3cb2c6b8d4f5c8257905ee7d32b4a5d2f1892170' }, this.renderEditor());
    }
};
ModusTableCellEditor.style = ModusTableCellEditorStyle0;

export { FlexRenderer as flex_renderer, ModusAutocomplete as modus_autocomplete, ModusDateInput as modus_date_input, ModusDatePicker as modus_date_picker, ModusNumberInput as modus_number_input, ModusSelect as modus_select, ModusTableCellEditor as modus_table_cell_editor };
