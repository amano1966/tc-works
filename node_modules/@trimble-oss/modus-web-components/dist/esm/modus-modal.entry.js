import { h, r as registerInstance, c as createEvent, F as Fragment, g as getElement } from './index-612c46d2.js';
import { I as IconClose } from './icon-close-fdd297f4.js';
import { a as IconCollapse, I as IconExpand } from './IconExpand-ccaa9f2c.js';

// Inspired by https://github.com/focus-trap/tabbable
const candidatesSelector = [
    'input',
    'select',
    'textarea',
    'a[href]',
    'button',
    '[tabindex]',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]:not([contenteditable="false"])',
].join(',');
function getTabIndex(node) {
    const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
    if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
    }
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    if (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName)) {
        return 0;
    }
    return node.tabIndex;
}
function isNodeFocusable(node) {
    if (node.disabled ||
        node['ariaHidden'] === 'true' ||
        (node.tagName === 'INPUT' && node.type === 'hidden') ||
        isNonTabbableRadio(node)) {
        return false;
    }
    return true;
}
const isNonTabbableRadio = function (node) {
    if (node.tagName !== 'INPUT' || node.type !== 'radio') {
        return false;
    }
    if (!node.name) {
        return false;
    }
    const queryRadios = function (name) {
        return node.ownerDocument.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    const radioSet = queryRadios(node.name);
    const checked = getCheckedRadio(radioSet, node.form);
    return !(!checked || checked === node);
};
const getCheckedRadio = function (nodes, form) {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
            return nodes[i];
        }
    }
};
const getTabbableNodes = function (root) {
    const zeroTabIndexNodes = [];
    const orderedTabNodes = [];
    // Workaround for Jest failing with an error "e.getAttributeNode is not a function", this code should be removed when a better fix is found.
    if (!root.getAttributeNode)
        return [];
    Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
        const nodeTabIndex = getTabIndex(node);
        if (nodeTabIndex === -1 || !isNodeFocusable(node)) {
            return;
        }
        if (nodeTabIndex === 0) {
            zeroTabIndexNodes.push(node);
        }
        else {
            orderedTabNodes.push({
                documentOrder: i,
                tabIndex: nodeTabIndex,
                node,
            });
        }
    });
    return orderedTabNodes
        .sort((a, b) => (a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex))
        .map((a) => a.node)
        .concat(zeroTabIndexNodes);
};
const FocusWrap = ({ id, ref, onFocus }) => {
    return h("div", { id: id, ref: ref, tabindex: "0", "aria-hidden": "true", onFocus: (e) => onFocus && onFocus(e) });
};
class ModalFocusWrapping {
    constructor(root, startWrap) {
        this.tababbleNodes = [];
        if (root)
            this.tababbleNodes = getTabbableNodes(root);
        this.startWrap = startWrap;
    }
    onStartWrapFocus() {
        var _a;
        if ((_a = this.tababbleNodes) === null || _a === void 0 ? void 0 : _a.length) {
            this.tababbleNodes[0].focus();
        }
    }
    onEndWrapFocus() {
        this.startWrap.focus();
    }
}

const modusModalCss = ".modus-modal{align-items:center;background-color:var(--modus-modal-backdrop-bg, rgba(37, 42, 46, 0.7490196078));font-size:0.875rem;height:100%;justify-content:center;left:0;overflow:auto;position:fixed;top:0;width:100%}.modus-modal.visible{display:inline-flex}.modus-modal.hidden{display:none}.modus-modal .content{background-color:var(--modus-modal-bg, #fff);border:1px solid var(--modus-modal-border-color, rgba(0, 0, 0, 0.2));border-radius:0.25rem;box-shadow:0 0 8px rgba(37, 42, 46, 0.3);color:var(--modus-modal-color, #252a2e);display:flex;fill:var(--modus-modal-color, #252a2e);flex-direction:column;justify-content:center;max-width:650px;min-width:300px;outline:0}.modus-modal .content header{align-items:center;display:flex;font-size:1rem;font-weight:700;height:64px;justify-content:space-between;padding:0 1rem}.modus-modal .content header.scrollable{border-bottom:1px solid var(--modus-modal-divider-color, #e0e1e9)}.modus-modal .content header .icon-close,.modus-modal .content header .icon-expand,.modus-modal .content header .icon-collapse{cursor:pointer}.modus-modal .content header .icon-close path,.modus-modal .content header .icon-expand path,.modus-modal .content header .icon-collapse path{fill:var(--modus-modal-close-color, #252a2e)}.modus-modal .content header .icon-close:hover path,.modus-modal .content header .icon-expand:hover path,.modus-modal .content header .icon-collapse:hover path{opacity:var(--modus-modal-close-hover-opacity, 0.75)}.modus-modal .content .header-buttons{align-items:center;display:flex;gap:0.5rem;justify-content:center;margin-left:auto}.modus-modal .content .header-buttons div{font-size:0}.modus-modal .content .body{height:auto;max-height:calc(100dvh - 188px);overflow-y:auto;padding:1rem}.modus-modal .content footer{padding:1.25rem 1rem}.modus-modal .content footer.scrollable{border-top:1px solid var(--modus-modal-divider-color, #e0e1e9)}.modus-modal .content footer.has-buttons{align-items:center;display:flex;gap:0.5rem;justify-content:flex-end}.modus-modal.fullscreen{overflow:hidden}.modus-modal.fullscreen .content{height:calc(100% - 64px);max-width:none;width:calc(100% - 64px)}.modus-modal.fullscreen .content .body{flex-grow:1}";
const ModusModalStyle0 = modusModalCss;

const ModusModal = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.closed = createEvent(this, "closed", 7);
        this.opened = createEvent(this, "opened", 7);
        this.primaryButtonClick = createEvent(this, "primaryButtonClick", 7);
        this.secondaryButtonClick = createEvent(this, "secondaryButtonClick", 7);
        this.ignoreOverlayClick = false;
        this.ariaLabel = undefined;
        this.headerText = undefined;
        this.primaryButtonAriaLabel = undefined;
        this.primaryButtonDisabled = undefined;
        this.primaryButtonText = undefined;
        this.secondaryButtonAriaLabel = undefined;
        this.secondaryButtonDisabled = undefined;
        this.secondaryButtonText = undefined;
        this.zIndex = '1';
        this.backdrop = 'default';
        this.showFullscreenToggle = false;
        this.fullscreen = false;
        this.isContentScrollable = false;
        this.visible = undefined;
    }
    /** Closes the Modal */
    async close() {
        if (!this.visible)
            return;
        this.visible = false;
        this.closed.emit();
        return Promise.resolve();
    }
    /** Opens the Modal */
    async open() {
        if (this.visible)
            return;
        this.visible = true;
        this.opened.emit();
        return Promise.resolve();
    }
    toggleFullscreen() {
        this.fullscreen = !this.fullscreen;
    }
    handleModalContentMouseDown() {
        // If Mouse was dragged off from the Modal content, ignore mouse up on overlay preventing Modal to close
        this.ignoreOverlayClick = true;
    }
    documentKeyHandler(event) {
        if (event.code.toUpperCase() === 'ESCAPE')
            this.close();
    }
    handleOverlayClick(event) {
        switch (this.backdrop) {
            case 'static':
                return;
            case 'default':
                if (this.ignoreOverlayClick || !event.target.classList.contains('overlay')) {
                    this.ignoreOverlayClick = false;
                    return;
                }
                this.close();
        }
    }
    handleEnterKeydown(event, callback) {
        if (event.code === 'Enter') {
            callback();
        }
    }
    handlePrimaryClick() {
        if (!this.primaryButtonDisabled) {
            this.primaryButtonClick.emit();
        }
    }
    handleSecondaryClick() {
        if (!this.secondaryButtonDisabled) {
            this.secondaryButtonClick.emit();
        }
    }
    componentDidRender() {
        if (this.modalContentRef && this.startTrapRef) {
            this.focusWrapping = new ModalFocusWrapping(this.modalContentRef, this.startTrapRef);
        }
        if (this.modalBodyRef) {
            this.resizeObserver = new ResizeObserver(() => {
                this.checkContentScrollable();
            });
            this.resizeObserver.observe(this.modalBodyRef);
        }
        this.checkContentScrollable();
    }
    disconnectedCallback() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
    }
    checkContentScrollable() {
        if (this.modalContentRef) {
            this.isContentScrollable = this.modalBodyRef.scrollHeight > this.modalBodyRef.clientHeight;
        }
    }
    renderModal() {
        return (h("div", { class: "content", ref: (el) => (this.modalContentRef = el), onMouseDown: () => this.handleModalContentMouseDown() }, h(FocusWrap, { id: "startTrap", ref: (el) => (this.startTrapRef = el), onFocus: () => { var _a; return (_a = this.focusWrapping) === null || _a === void 0 ? void 0 : _a.onStartWrapFocus(); } }), this.renderModalHeader(), h("div", { class: "body", ref: (el) => (this.modalBodyRef = el) }, h("slot", null)), this.renderModalFooter(), h(FocusWrap, { id: "endTrap", onFocus: () => { var _a; return (_a = this.focusWrapping) === null || _a === void 0 ? void 0 : _a.onEndWrapFocus(); } })));
    }
    renderModalHeader() {
        return (h("header", { class: { scrollable: this.isContentScrollable } }, this.headerText, h("div", { class: "header-buttons" }, this.showFullscreenToggle && (h("div", { role: "button", tabindex: 0, "aria-label": this.fullscreen ? 'Collapse' : 'Expand', onClick: () => this.toggleFullscreen(), onKeyDown: (event) => this.handleEnterKeydown(event, () => this.toggleFullscreen()) }, this.fullscreen ? h(IconCollapse, { size: "24" }) : h(IconExpand, { size: "24" }))), h("div", { role: "button", tabindex: 0, "aria-label": "Close", onClick: () => this.close(), onKeyDown: (event) => this.handleEnterKeydown(event, () => this.close()) }, h(IconClose, { size: "24" })))));
    }
    renderModalFooter() {
        return (h(Fragment, null, h("footer", { class: {
                'has-buttons': Boolean(this.primaryButtonText || this.secondaryButtonText),
                scrollable: this.isContentScrollable,
            } }, this.secondaryButtonText && (h("modus-button", { disabled: this.secondaryButtonDisabled, "button-style": "outline", color: "secondary", ariaLabel: this.secondaryButtonAriaLabel, onButtonClick: () => this.handleSecondaryClick() }, this.secondaryButtonText)), this.primaryButtonText && (h("modus-button", { disabled: this.primaryButtonDisabled, color: "primary", ariaLabel: this.primaryButtonAriaLabel, onButtonClick: () => this.handlePrimaryClick() }, this.primaryButtonText)), h("slot", { name: "footerContent" }))));
    }
    render() {
        return (h("div", { key: '763cdb0f034096b6ba74cf9041db50350fc50d21', "aria-hidden": this.visible ? undefined : 'true', "aria-label": this.visible ? this.ariaLabel || undefined : undefined, "aria-modal": this.visible ? 'true' : undefined, class: `modus-modal ${this.fullscreen ? 'fullscreen' : ''} overlay ${this.visible ? 'visible' : 'hidden'}`, onClick: (event) => this.handleOverlayClick(event), role: this.visible ? 'dialog' : undefined, style: { zIndex: this.zIndex } }, this.renderModal()));
    }
    get el() { return getElement(this); }
};
ModusModal.style = ModusModalStyle0;

export { ModusModal as modus_modal };
