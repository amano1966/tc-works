import { p as proxyCustomElement, H, h, c as Host } from './p-85681586.js';
import { p as CELL_EDIT_TYPE_TEXT, q as CELL_EDIT_TYPE_INT, r as CELL_EDIT_TYPE_DATE, s as CELL_EDIT_TYPE_AUTOCOMPLETE, t as CELL_EDIT_TYPE_SELECT, u as KEYBOARD_UP, v as KEYBOARD_DOWN, f as KEYBOARD_ENTER } from './p-5d1d55be.js';
import { d as defineCustomElement$8 } from './p-57104bdf.js';
import { d as defineCustomElement$7 } from './p-712cbdfb.js';
import { d as defineCustomElement$6 } from './p-854b47fa.js';
import { d as defineCustomElement$5 } from './p-f5c6b288.js';
import { d as defineCustomElement$4 } from './p-92734348.js';
import { d as defineCustomElement$3 } from './p-9158ea44.js';
import { d as defineCustomElement$2 } from './p-1b7ef7fc.js';
import { d as defineCustomElement$1 } from './p-ba98e9ed.js';

const modusTableCellEditorCss = ":host{--modus-autocomplete-border:none;--modus-autocomplete-border-active:none;--modus-autocomplete-font-size:14px;--modus-input-border-color:none}.editor::part(input-container),.editor::part(input){height:2.9375rem !important}table.density-comfortable .editor::part(input-container),table.density-comfortable .editor::part(input){height:1.75rem !important}table.density-compact .editor::part(input-container),table.density-compact .editor::part(input){height:1.25rem !important}.autocomplete-container{margin-left:4px;margin-top:5px}.editor::part(sub-text){display:none}.date-picker-container::part(date-inputs){align-items:center;display:flex;justify-content:center}.date-picker-container::part(calendar){z-index:99}.editor::part(input-container){border:2px solid var(--modus-input-border-active-color, #217cbb);border-radius:unset;z-index:99}.editor::part(input-container error){border:2px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;z-index:99}.error .editor::part(input-container){border:1px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;box-shadow:2px solid var(--modus-input-border-active-color, #da212c);z-index:99}.error-tooltip{background-color:var(--modus-input-validation-error-color, #da212c);border-radius:2px;color:#fff;display:none;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:12px;font-weight:600;letter-spacing:0.005em;line-height:15px;max-width:200px;padding:5px 8px;text-align:left;word-wrap:break-word;z-index:10}";
const ModusTableCellEditorStyle0 = modusTableCellEditorCss;

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModusTableCellEditor = /*@__PURE__*/ proxyCustomElement(class ModusTableCellEditor extends H {
    constructor() {
        super();
        this.__registerHost();
        this.handleBlur = () => {
            this.valueChange(this.editedValue);
        };
        this.handleKeyDown = (e) => {
            this.keyDown(e, this.editedValue);
        };
        this.getDefaultProps = (ariaLabel) => ({
            'aria-label': ariaLabel,
            class: 'editor',
            ref: (ref) => (this.inputElement = ref),
        });
        this.args = undefined;
        this.dataType = undefined;
        this.value = undefined;
        this.type = undefined;
        this.valueChange = undefined;
        this.keyDown = undefined;
        this.inputValueChangeHandler = undefined;
    }
    connectedCallback() {
        this.editedValue = this.value;
    }
    componentDidLoad() {
        if (this.inputElement['focusInput']) {
            this.inputElement['focusInput']();
        }
    }
    handleDocumentClick(event) {
        if (this.type != 'date') {
            return;
        }
        const target = event.target;
        if (!this.inputElement.contains(target)) {
            this.handleBlur();
        }
    }
    renderNumberInput() {
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("modus-number-input", Object.assign({}, this.getDefaultProps('Number input'), { value: this.value, textAlign: "right", size: "large", onBlur: this.handleBlur, onValueChange: (e) => (this.editedValue = e.detail), onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown) })));
    }
    renderTextInput() {
        return (h("modus-text-input", Object.assign({}, this.getDefaultProps('Text input'), { value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail;
                this.inputValueChangeHandler(e.detail);
            }, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, autoFocusInput: true, size: "large" })));
    }
    renderSelectInput() {
        const valueKey = 'display';
        const args = this.args;
        const options = (args === null || args === void 0 ? void 0 : args.options) || [];
        const optionsDisplayProp = (args === null || args === void 0 ? void 0 : args.optionsDisplayProp) || valueKey;
        const placeholder = args === null || args === void 0 ? void 0 : args.placeholder;
        const selectedOption = options.find((option) => option[optionsDisplayProp] === this.value);
        function handleEnter(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_ENTER) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", null, h("modus-select", Object.assign({}, this.getDefaultProps('Select input'), { value: selectedOption, "options-display-prop": optionsDisplayProp, size: "large", options: options, placeholder: placeholder, onInputBlur: this.handleBlur, onKeyDown: (e) => handleEnter(e, this.handleKeyDown), onValueChange: (e) => {
                const detail = e.detail;
                if (this.dataType === 'badge') {
                    const { display } = detail, restProps = __rest(detail, ["display"]);
                    this.editedValue = Object.assign(Object.assign({}, restProps), { text: display });
                }
                else if (this.dataType === 'link') {
                    this.editedValue = detail;
                }
                else {
                    this.editedValue = detail[valueKey];
                }
            } }))));
    }
    renderDateInput() {
        var _a;
        const valueKey = 'value';
        const format = (_a = this.args) === null || _a === void 0 ? void 0 : _a.format;
        return (h("modus-date-picker", { onBlur: this.handleBlur, position: "auto", onClick: (e) => e.stopPropagation(), class: "date-picker-container" }, h("modus-date-input", Object.assign({}, this.getDefaultProps('Date input'), { format: format, size: "large", "show-calendar-icon": "true", value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail[valueKey];
            } }))));
    }
    renderAutocompleteInput() {
        var _a, _b;
        const args = this.args;
        let options = [];
        let selectedOption = '';
        if (this.dataType === 'badge') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.text);
            selectedOption = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.text) || '';
        }
        else if (this.dataType === 'link') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.display);
            selectedOption = ((_b = this.value) === null || _b === void 0 ? void 0 : _b.display) || '';
        }
        else {
            options = ((args === null || args === void 0 ? void 0 : args.options) || []);
            selectedOption = this.editedValue;
        }
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", { class: "autocomplete-container" }, h("modus-autocomplete", Object.assign({}, this.getDefaultProps('Autocomplete input'), { "include-search-icon": "false", size: "medium", ref: (el) => (this.inputElement = el), options: options, onBlur: this.handleBlur, onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown), filterOptions: args.filterOptions
                ? (...props) => {
                    if (this.inputElement && (args === null || args === void 0 ? void 0 : args.filterOptions)) {
                        this.inputElement.loading = true;
                        return args === null || args === void 0 ? void 0 : args.filterOptions(...props).finally(() => {
                            this.inputElement.loading = false;
                        });
                    }
                }
                : undefined, onOptionSelected: (e) => {
                const selectedDetail = e.detail;
                if (this.dataType === 'badge') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.text === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else if (this.dataType === 'link') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.display === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else {
                    this.editedValue = selectedDetail;
                }
            }, value: selectedOption }))));
    }
    renderEditor() {
        switch (this.type) {
            case CELL_EDIT_TYPE_SELECT:
                return this.renderSelectInput();
            case CELL_EDIT_TYPE_AUTOCOMPLETE:
                return this.renderAutocompleteInput();
            case CELL_EDIT_TYPE_DATE:
                return this.renderDateInput();
            case CELL_EDIT_TYPE_INT:
                return this.renderNumberInput();
            case CELL_EDIT_TYPE_TEXT:
            default:
                return this.renderTextInput();
        }
    }
    render() {
        return h(Host, { key: '3cb2c6b8d4f5c8257905ee7d32b4a5d2f1892170' }, this.renderEditor());
    }
    static get style() { return ModusTableCellEditorStyle0; }
}, [0, "modus-table-cell-editor", {
        "args": [16],
        "dataType": [1, "data-type"],
        "value": [16],
        "type": [1],
        "valueChange": [16],
        "keyDown": [16],
        "inputValueChangeHandler": [16]
    }, [[4, "click", "handleDocumentClick"]]]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-table-cell-editor", "modus-autocomplete", "modus-chip", "modus-date-input", "modus-date-picker", "modus-number-input", "modus-select", "modus-spinner", "modus-text-input"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-table-cell-editor":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusTableCellEditor);
            }
            break;
        case "modus-autocomplete":
            if (!customElements.get(tagName)) {
                defineCustomElement$8();
            }
            break;
        case "modus-chip":
            if (!customElements.get(tagName)) {
                defineCustomElement$7();
            }
            break;
        case "modus-date-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$6();
            }
            break;
        case "modus-date-picker":
            if (!customElements.get(tagName)) {
                defineCustomElement$5();
            }
            break;
        case "modus-number-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$4();
            }
            break;
        case "modus-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "modus-spinner":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "modus-text-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}

export { ModusTableCellEditor as M, defineCustomElement as d };
