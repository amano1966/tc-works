import { p as proxyCustomElement, H, d as createEvent, h, c as Host } from './p-85681586.js';

const SINGLE_SELECTION_TYPE = 'single';
const MULTIPLE_SELECTION_TYPE = 'multiple';
const DEFAULT_SELECTION_TYPE = 'none';
const SELECTION_ATTRIBUTE = 'selected';

const modusButtonGroupCss = ":host{display:flex}:host slot::slotted(modus-button){display:block;margin:0;--btn-border-radius:0;--btn-border-left-width:0.0625rem;--btn-border-right-width:0}:host slot::slotted(modus-button:first-child){--btn-border-radius:0.25rem 0 0 0.25rem}:host slot::slotted(modus-button:last-child){--btn-border-radius:0 0.25rem 0.25rem 0;--btn-border-right-width:0.0625rem}:host slot::slotted(modus-button:only-child){--btn-border-radius:0.25rem}";
const ModusButtonGroupStyle0 = modusButtonGroupCss;

const ModusButtonGroup$1 = /*@__PURE__*/ proxyCustomElement(class ModusButtonGroup extends H {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.buttonGroupClick = createEvent(this, "buttonGroupClick", 7);
        this.buttonSelectionChange = createEvent(this, "buttonSelectionChange", 7);
        /** Array to store selected buttons */
        this.selectedButtons = [];
        this.observer = null;
        this.ariaDisabled = undefined;
        this.ariaLabel = undefined;
        this.buttonStyle = 'outline';
        this.color = 'primary';
        this.disabled = undefined;
        this.selectionType = DEFAULT_SELECTION_TYPE;
        this.size = 'medium';
    }
    selectionTypeChanged(newValue) {
        if (newValue === DEFAULT_SELECTION_TYPE) {
            this.selectedButtons.forEach((button) => button.setActive(false));
            this.selectedButtons = [];
        }
    }
    disabledChanged() {
        this.setupButtons(true);
    }
    sizeChanged() {
        this.setupButtons();
    }
    componentWillLoad() {
        this.setupButtons();
    }
    componentDidLoad() {
        this.observer = new MutationObserver(this.handleMutations.bind(this));
        this.observer.observe(this.host, { subtree: true, attributes: true, attributeFilter: [SELECTION_ATTRIBUTE] });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    handleSlotChange() {
        this.setupButtons();
    }
    handleButtonClick(event) {
        const clickedButton = event.target;
        if (this.selectionType === DEFAULT_SELECTION_TYPE) {
            return;
        }
        switch (this.selectionType) {
            case SINGLE_SELECTION_TYPE:
                this.toggleSingleSelect(clickedButton);
                break;
            case MULTIPLE_SELECTION_TYPE:
                this.toggleMultiSelect(clickedButton);
                break;
        }
        this.buttonSelectionChange.emit(this.selectedButtons);
        this.buttonGroupClick.emit({ button: clickedButton, isSelected: this.selectedButtons.includes(clickedButton) });
    }
    handleMutations(mutationList) {
        for (const mutation of mutationList) {
            if (mutation.type === 'attributes' && mutation.attributeName === SELECTION_ATTRIBUTE) {
                this.setupButtons();
            }
        }
    }
    handleButtonSelection(button, isSelected) {
        if (isSelected) {
            button.setActive(true);
            this.selectedButtons.push(button);
        }
        else {
            button.setActive(false);
            if (this.selectedButtons.includes(button)) {
                this.selectedButtons = this.selectedButtons.filter((selectedButton) => selectedButton !== button);
            }
        }
    }
    setupButtons(reset) {
        customElements.whenDefined('modus-button').then(() => {
            const buttons = this.host.querySelectorAll('modus-button');
            this.renderButtons(buttons, reset);
        });
    }
    renderButtons(buttons, reset) {
        const buttonType = this.determineButtonType();
        let foundSelected = false;
        buttons.forEach((button) => {
            if (reset) {
                button.ariaDisabled = this.ariaDisabled;
                button.disabled = this.disabled;
            }
            else {
                button.ariaDisabled = button.ariaDisabled || this.ariaDisabled;
                button.disabled = button.disabled || this.disabled;
            }
            button.buttonStyle = this.buttonStyle;
            button.color = this.color;
            button.size = this.size;
            button.type = buttonType;
            const isSelected = button.hasAttribute(SELECTION_ATTRIBUTE) && button.getAttribute(SELECTION_ATTRIBUTE) !== 'false';
            if (this.selectionType === SINGLE_SELECTION_TYPE) {
                if (isSelected && !foundSelected) {
                    this.handleButtonSelection(button, true);
                    foundSelected = true;
                }
                else {
                    this.handleButtonSelection(button, false);
                }
            }
            else if (this.selectionType === MULTIPLE_SELECTION_TYPE) {
                this.handleButtonSelection(button, isSelected);
            }
        });
    }
    determineButtonType() {
        return this.selectionType === DEFAULT_SELECTION_TYPE ? 'button' : 'toggle';
    }
    toggleMultiSelect(clickedButton) {
        const isSelected = this.selectedButtons.includes(clickedButton);
        clickedButton.setActive(!isSelected);
        this.selectedButtons = isSelected
            ? this.selectedButtons.filter((button) => button !== clickedButton)
            : [...this.selectedButtons, clickedButton];
    }
    toggleSingleSelect(clickedButton) {
        const wasActive = this.selectedButtons.includes(clickedButton);
        this.selectedButtons.forEach((button) => button.setActive(false));
        this.selectedButtons = wasActive ? [] : [clickedButton];
        if (!wasActive)
            clickedButton.setActive(true);
    }
    render() {
        return (h(Host, { key: 'd8b941eec339bb068a23b6aec06c5e9c49449d31', "aria-label": this.ariaLabel, "aria-disabled": this.ariaDisabled ? this.ariaDisabled : this.disabled ? 'true' : undefined, role: "group" }, h("slot", { key: 'f593f0ffe06268419d7da12f8cb8290e7fb01269' })));
    }
    get host() { return this; }
    static get watchers() { return {
        "selectionType": ["selectionTypeChanged"],
        "disabled": ["disabledChanged"],
        "buttonStyle": ["sizeChanged"],
        "color": ["sizeChanged"],
        "size": ["sizeChanged"]
    }; }
    static get style() { return ModusButtonGroupStyle0; }
}, [1, "modus-button-group", {
        "ariaDisabled": [1, "aria-disabled"],
        "ariaLabel": [1, "aria-label"],
        "buttonStyle": [1, "button-style"],
        "color": [1],
        "disabled": [516],
        "selectionType": [1, "selection-type"],
        "size": [1]
    }, [[0, "slotchange", "handleSlotChange"], [0, "buttonClick", "handleButtonClick"]], {
        "selectionType": ["selectionTypeChanged"],
        "disabled": ["disabledChanged"],
        "buttonStyle": ["sizeChanged"],
        "color": ["sizeChanged"],
        "size": ["sizeChanged"]
    }]);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-button-group"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-button-group":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusButtonGroup$1);
            }
            break;
    } });
}

const ModusButtonGroup = ModusButtonGroup$1;
const defineCustomElement = defineCustomElement$1;

export { ModusButtonGroup, defineCustomElement };
