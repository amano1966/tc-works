import { h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from "@stencil/core";
import { ModusTableCell } from "./cell/modus-table-cell";
import { ModusTableCellCheckbox } from "./row/selection/modus-table-cell-checkbox";
import { COLUMN_DEF_SUB_ROWS_KEY } from "../modus-table.constants";
export const ModusTableBody = ({ context }) => {
    var _a;
    const { density, hover, rowSelection, rowSelectionOptions, rowActions, rowsExpandable, tableInstance: table, updateData, updateSelectedRows, updateClickedRows, } = context;
    const hasRowActions = (rowActions === null || rowActions === void 0 ? void 0 : rowActions.length) > 0;
    const multipleRowSelection = rowSelectionOptions === null || rowSelectionOptions === void 0 ? void 0 : rowSelectionOptions.multiple;
    let checkboxSize = 'medium';
    if (density === 'compact') {
        checkboxSize = 'small';
    }
    // Note: This function supports only 3 levels of nested rows.
    function handleCellValueChange(props) {
        const { row, accessorKey, newValue } = props;
        updateData((old) => {
            const newData = [...old];
            // rowId is a string of IDs for rows with nested information like subrows.
            const idArray = [];
            let currentRow = row;
            while (currentRow) {
                idArray.push(currentRow['index']);
                currentRow = currentRow['parent'];
            }
            idArray.reverse();
            if (idArray.length === 1) {
                newData[idArray[0]][accessorKey] = newValue;
            }
            else if (idArray.length === 2) {
                newData[idArray[0]][COLUMN_DEF_SUB_ROWS_KEY][idArray[1]][accessorKey] = newValue;
            }
            else if (idArray.length === 3) {
                newData[idArray[0]][COLUMN_DEF_SUB_ROWS_KEY][idArray[1]][COLUMN_DEF_SUB_ROWS_KEY][idArray[2]][accessorKey] =
                    newValue;
            }
            return newData;
        }, Object.assign(Object.assign({}, props), { row: row['original'] }));
    }
    function handleRowClick(event, currentRowIndex, row) {
        if ((!rowSelectionOptions.subRowSelection && rowSelectionOptions.multiple && rowsExpandable) ||
            !rowSelectionOptions.multiple) {
            row.toggleSelected();
            return;
        }
        const isShiftClick = event.shiftKey;
        updateClickedRows(currentRowIndex, isShiftClick);
    }
    function handleKeyDown(event, currentRowIndex) {
        if (event.defaultPrevented || event.altKey || !event.shiftKey) {
            return;
        }
        const rowCount = table.getExpandedRowModel().rows.length;
        const step = event.key === 'ArrowUp' ? -1 : event.key === 'ArrowDown' ? 1 : 0;
        if (!step)
            return;
        const nextRowIndex = currentRowIndex + step;
        if (nextRowIndex >= 0 && nextRowIndex < rowCount) {
            event.preventDefault();
            updateSelectedRows(nextRowIndex, currentRowIndex);
        }
    }
    function handleCheckboxKeyDown(row) {
        if ((!rowSelectionOptions.subRowSelection && rowSelectionOptions.multiple && rowsExpandable) ||
            !rowSelectionOptions.multiple) {
            row.toggleSelected();
            return;
        }
        updateClickedRows(row.index, false);
    }
    return (h("tbody", null, (_a = table.getRowModel()) === null || _a === void 0 ? void 0 : _a.rows.map((row) => {
        var _a;
        const { getIsSelected, getIsAllSubRowsSelected, getVisibleCells, subRows, id } = row;
        const isChecked = getIsSelected() && ((subRows === null || subRows === void 0 ? void 0 : subRows.length) ? getIsAllSubRowsSelected() : true);
        const isDisabled = context.rowSelectionDisabled ? context.rowSelectionDisabled(row) : false;
        return (h("tr", Object.assign({ key: id, class: { 'enable-hover': hover, 'row-selected': isChecked, 'row-disabled': isDisabled }, onClick: isDisabled ? undefined : (event) => handleRowClick(event, row.index, row) }, (rowSelectionOptions.multiple &&
            !isDisabled && {
            onKeyDown: (event) => handleKeyDown(event, row.index),
        })), rowSelection && (h(ModusTableCellCheckbox, { multipleRowSelection: multipleRowSelection, row: row, isChecked: isChecked, checkboxSize: checkboxSize, updateRow: isDisabled ? undefined : () => handleCheckboxKeyDown(row), disableRow: isDisabled })), (_a = getVisibleCells()) === null || _a === void 0 ? void 0 :
            _a.map((cell, cellIndex) => {
                return (h(ModusTableCell, { cell: cell, cellIndex: cellIndex, context: context, valueChange: handleCellValueChange }));
            }), hasRowActions && (h("td", { class: "sticky-right", tabindex: "0" }, h("modus-table-row-actions-cell", { row: row, context: context })))));
    })));
};
