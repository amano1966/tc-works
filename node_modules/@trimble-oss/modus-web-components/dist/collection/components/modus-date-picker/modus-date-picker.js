import { h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from "@stencil/core";
import { ModusIconMap } from "../../icons/ModusIconMap";
import ModusDatePickerCalendar from "./utils/modus-date-picker.calendar";
import ModusDatePickerState from "./utils/modus-date-picker.state";
import { autoPlacement, flip, autoUpdate, computePosition, shift, limitShift, } from "@floating-ui/dom";
export class ModusDatePicker {
    constructor() {
        this._dateInputs = {};
        this._locale = 'default';
        this.cleanupPopover = undefined;
        this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
        this.label = undefined;
        this.position = 'bottom-start';
        this.isDateEnabled = undefined;
        this._forceUpdate = {};
        this._showCalendar = false;
        this._showYearArrows = false;
    }
    get _currentInput() {
        return Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
    componentWillLoad() {
        this._calendar = new ModusDatePickerCalendar();
    }
    componentDidUpdate() {
        var _a;
        if (this._showCalendar) {
            this.configureCalendarPopover();
        }
        else {
            (_a = this.cleanupPopover) === null || _a === void 0 ? void 0 : _a.call(this);
        }
    }
    disconnectedCallback() {
        var _a;
        (_a = this.cleanupPopover) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    configureCalendarPopover() {
        const referenceElement = this.element.shadowRoot.querySelector('.calendar');
        const floatingElement = this.element.shadowRoot.querySelector('.calendar-container');
        this.cleanupPopover = autoUpdate(referenceElement, floatingElement, () => {
            const options = {};
            const middleware = [];
            // The preventOverflow modifier from Popper is now called shift.
            // This is because technically many modifiers in Popper 2 “prevented overflow”,
            // which does not describe what it is actually doing unlike shift. (https://floating-ui.com/docs/migration#configure-middleware)
            middleware.push(shift({ limiter: limitShift() }));
            if (this.position.includes('auto')) {
                const autoPlacementOptions = {};
                if (this.position.includes('-')) {
                    const [, alignment] = this.position.split('-');
                    autoPlacementOptions.alignment = alignment;
                }
                middleware.push(autoPlacement(autoPlacementOptions));
            }
            else {
                options.placement = this.position;
                middleware.push(flip());
            }
            if (this.position === 'auto') {
                options.strategy = 'fixed';
            }
            options.middleware = middleware;
            computePosition(referenceElement, floatingElement, options).then(({ x, y }) => {
                Object.assign(floatingElement.style, {
                    left: `${x}px`,
                    top: `${y}px`,
                });
            });
        });
    }
    /** Handlers */
    handleCalendarIconClick(event) {
        const { type } = event.detail;
        Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
        this.toggleCalendar();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleClickOutside(event) {
        const path = event.composedPath();
        const insideComponent = path.includes(this.element);
        if (insideComponent || event.defaultPrevented) {
            return;
        }
        // Collapse when clicked outside
        this.toggleCalendar(false);
    }
    handleDateInputValue(event) {
        const { type } = event.detail;
        if (!this._dateInputs[type])
            return;
        this._dateInputs[type].refresh();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleDateInputBlur() {
        var _a, _b;
        this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
    }
    handleSlotChange() {
        const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
        dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
            this._dateInputs[d.type] = new ModusDatePickerState(d);
        });
    }
    /** Helpers */
    addMonthOffset(offset) {
        this._calendar.addMonthOffset(offset);
        this.forceUpdate();
    }
    addYearOffset(offset) {
        this._calendar.addYearOffset(offset);
        this.forceUpdate();
    }
    applyDateRangeRules(startDate, endDate) {
        if (!startDate || !endDate) {
            return;
        }
        if (this.isInvalidDateRange(startDate, endDate)) {
            this._dateInputs['start'].setError('Invalid date range');
            this._dateInputs['end'].setError();
        }
        else {
            this._dateInputs['start'].setError('');
            this._dateInputs['end'].setError('');
            this._dateInputs['start'].validateInput();
            this._dateInputs['end'].validateInput();
        }
    }
    compare(date1, date2) {
        if (!date1 && !date2) {
            return 0;
        }
        else if (!date1 && date2) {
            return -1;
        }
        else if (date1 && !date2) {
            return 1;
        }
        let delta;
        delta = date1.getFullYear() - date2.getFullYear();
        if (delta !== 0) {
            return delta;
        }
        delta = date1.getMonth() - date2.getMonth();
        if (delta !== 0) {
            return delta;
        }
        return date1.getDate() - date2.getDate();
    }
    forceUpdate() {
        this._forceUpdate = Object.assign({}, this._forceUpdate);
    }
    findDatePositionsInARange(date, startDate, endDate) {
        return {
            start: startDate && this.compare(date, startDate) === 0,
            end: endDate && this.compare(date, endDate) === 0,
            'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
        };
    }
    gotoDateBeingPicked(pickedDate) {
        if (!this._showCalendar) {
            return;
        }
        const date = pickedDate || new Date();
        this._calendar.gotoDate(date.getFullYear(), date.getMonth());
    }
    goToNearestBoundaryDate(date) {
        var _a, _b;
        const minDate = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMinDateAllowed();
        const maxDate = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMaxDateAllowed();
        const targetDate = this.compare(date, minDate) < 0 ? minDate : maxDate;
        this.gotoDateBeingPicked(targetDate);
        this.forceUpdate();
    }
    pickCalendarDate(date) {
        this._currentInput.setDate(date);
        this.toggleCalendar(false);
    }
    showYearChange(show = true) {
        this._showYearArrows = show;
    }
    isWithinCurrentMinMax(date) {
        var _a, _b;
        const max = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMaxDateAllowed();
        const min = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMinDateAllowed();
        if (!date) {
            return false;
        }
        if (min && this.compare(date, min) < 0) {
            return false;
        }
        if (max && this.compare(date, max) > 0) {
            return false;
        }
        return true;
    }
    toggleCalendar(val = null) {
        if (val !== null) {
            this._showCalendar = val;
            if (!this._showCalendar) {
                Object.keys(this._dateInputs || {}).forEach((d) => {
                    this._dateInputs[d].toggleCalendar(false);
                });
            }
        }
        else {
            this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
        }
    }
    renderCalendarBody() {
        var _a, _b, _c, _d;
        const today = new Date();
        const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
        const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
        const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
        // Get day of the week and prepare blank cells to render the calendar dates properly
        const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
        const blankDatesArr = new Array(firstDay).fill(0);
        return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
            return h("div", { class: "grid-item" }, d);
        })), h("div", { class: "calendar-month-container" }, h("div", { class: {
                'calendar-month grid': true,
                'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
            } }, blankDatesArr &&
            blankDatesArr.length > 0 &&
            blankDatesArr.map(() => {
                return (h("button", { class: {
                        'calendar-day grid-item': false,
                        disabled: true,
                    }, disabled: true, tabIndex: -1 }, "\u00A0"));
            }), this._calendar.dates.map((date, index) => {
            if (!date) {
                return null;
            }
            const positions = this.findDatePositionsInARange(date, startDate, endDate);
            const isStartDate = positions['start'];
            const isEndDate = positions['end'];
            const isToday = this.compare(date, today) === 0;
            const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
            const isSelected = isStartDate || isEndDate || isSingleDateSelected;
            const isInRange = !isSelected ? positions['in-range'] : false;
            const isDateOutOfMaxMinRange = !this.isWithinCurrentMinMax(date);
            const isDateEnabled = this.isDateEnabled ? this.isDateEnabled(date.toISOString()) : true;
            // Only for the last date in the calendar
            const onBlurEvent = index === this._calendar.dates.length - 1
                ? {
                    onBlur: () => {
                        this.toggleCalendar(false);
                    },
                }
                : {};
            const buttonDisabled = isDateOutOfMaxMinRange || !isDateEnabled;
            return (h("button", Object.assign({ class: {
                    'calendar-day grid-item': true,
                    selected: isSelected,
                    disabled: buttonDisabled,
                    start: isStartDate && !isEndDate,
                    end: isEndDate && !isStartDate,
                    'current-day': isToday,
                    'range-selected': isInRange,
                }, disabled: buttonDisabled, tabIndex: 0, type: "button", "aria-current": isSelected ? 'date' : undefined, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
        }))), !this.isWithinCurrentMinMax(this._currentInput.getDate()) && (h("div", { class: "out-of-range-notification" }, h("div", null, "The selected date is not available"), h("span", { class: "goto-available-dates", onClick: () => this.goToNearestBoundaryDate(this._currentInput.getDate()) }, "Go to available dates")))));
    }
    renderCalendarHeader() {
        var _a, _b;
        return (h("div", { class: "calendar-header" }, h("button", { type: "button", "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(ModusIconMap, { icon: "chevron_left_bold" })), h("div", { class: "title" }, h("div", { class: "calendar-title", role: "heading" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { type: "button", tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(ModusIconMap, { icon: "caret_up", size: "16" })), h("button", { type: "button", tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(ModusIconMap, { size: "16", icon: "caret_down" })))), h("button", { type: "button", tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(ModusIconMap, { icon: "chevron_right_bold" }))));
    }
    render() {
        return (h("div", { key: '296f45926a5e4e7faf415fafa9ad149c56661f9e', class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { key: '7ac0f29be1e1ad25531a24714dd520050c7d4604', class: "date-inputs", part: "date-inputs" }, h("slot", { key: 'b40cf940b60aa59f452b2da88e07bd8ebb5d418b', onSlotchange: () => this.handleSlotChange() })), h("div", { key: 'fc6cb1a09499860ae721fc96b757fb67f67a4fc7', class: "calendar", part: "calendar", style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
    }
    static get is() { return "modus-date-picker"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["modus-date-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["modus-date-picker.css"]
        };
    }
    static get properties() {
        return {
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Label for the field."
                },
                "attribute": "label",
                "reflect": false
            },
            "position": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "Placement | 'auto' | 'auto-start' | 'auto-end'",
                    "resolved": "\"auto\" | \"auto-end\" | \"auto-start\" | \"bottom\" | \"bottom-end\" | \"bottom-start\" | \"left\" | \"left-end\" | \"left-start\" | \"right\" | \"right-end\" | \"right-start\" | \"top\" | \"top-end\" | \"top-start\"",
                    "references": {
                        "Placement": {
                            "location": "import",
                            "path": "@floating-ui/dom",
                            "id": ""
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) The placement of the calendar popup"
                },
                "attribute": "position",
                "reflect": false,
                "defaultValue": "'bottom-start'"
            },
            "isDateEnabled": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "(dateIsoString: string) => boolean | undefined",
                    "resolved": "(dateIsoString: string) => boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Function to check if a date is enabled\nIf true, the day will be enabled/interactive. If false, the day will be disabled/non-interactive.\nThe function accepts an ISO 8601 date string of a given day. By default, all days are enabled.\nDevelopers can use this function to write custom logic to disable certain days.\nThe function is called for each rendered calendar day.\nThis function should be optimized for performance to avoid jank."
                }
            }
        };
    }
    static get states() {
        return {
            "_forceUpdate": {},
            "_showCalendar": {},
            "_showYearArrows": {}
        };
    }
    static get elementRef() { return "element"; }
    static get listeners() {
        return [{
                "name": "calendarIconClicked",
                "method": "handleCalendarIconClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "click",
                "method": "handleClickOutside",
                "target": "document",
                "capture": false,
                "passive": false
            }, {
                "name": "valueChange",
                "method": "handleDateInputValue",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "dateInputBlur",
                "method": "handleDateInputBlur",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
