{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sok_asset/./node_modules/trimble-connect-workspace-api/dist/es/trimbleconnect.workspace.api.js","webpack://sok_asset/./src/api/api.js","webpack://sok_asset/./src/api/auth.js","webpack://sok_asset/./src/api/detailTask.js","webpack://sok_asset/./src/api/errorConsole.js","webpack://sok_asset/webpack/bootstrap","webpack://sok_asset/webpack/runtime/define property getters","webpack://sok_asset/webpack/runtime/global","webpack://sok_asset/webpack/runtime/hasOwnProperty shorthand","webpack://sok_asset/webpack/runtime/make namespace object","webpack://sok_asset/./src/index.js"],"sourcesContent":["const e={postMessage:(e,n)=>{const t=JSON.stringify(e);connectWsApiIntegrator.postMessage(t)}},n={postMessage:(e,n)=>{window.chrome.webview.postMessage(e)}},t={postMessage:(e,n)=>{window.webkit.messageHandlers.webwindowinterop.postMessage(e)}},i={postMessage:(e,n)=>{const t=JSON.stringify(e);window.hybridWebViewHost.sendMessage(t)}},r=()=>crypto.randomUUID(),o=()=>{const e=window;return!!(e&&e.chrome&&e.chrome.webview)},s=()=>{const e=window;return!(!e||!(\"CefSharp\"in e))},a=async()=>(window.connectWsApiIntegrator||await CefSharp.BindObjectAsync(\"connectWsApiIntegrator\"),e),c=()=>n,u=async e=>{let n;return n=e===window?s()?await a():o()?c():e:e,n},f=\"Trimble.dispatcher.v1\",d={},p={};let l=1;function w(e){const n=m();return p[n]=e,()=>delete p[n]}function g(e,n,t,i,r=3e5){return new Promise(((o,s)=>{const a=m(),c={scope:f,type:\"request\",id:a,api:t,args:i};let u;r>0&&(u=setTimeout((()=>{delete d[a],s(new Error(\"dispatcher.ts | sendRequest(): Operation timed out.\"))}),r)),d[a]=e=>{delete d[a],u&&clearTimeout(u),e.error?s(e.error):o(e.result)},e.postMessage(c,n)}))}function h(e,n,t,i){const r={scope:f,type:\"event\",event:t,data:i};u(e).then((e=>{e.postMessage(r,n)})).catch((e=>{console.error(\"sendEvent() call failed\",e)}))}async function y(e){const n=\"null\"===e.origin?\"*\":e.origin,t=e.data;if(function(e){return b(e)&&\"event\"===e.type}(t))for(const i in p){if(!p.hasOwnProperty(i))continue;const r=p[i].event;if(r){r(e.source,n,t.event,t.data)}}else if(function(e){return b(e)&&\"request\"===e.type}(t)){const i=await u(e.source);let r;for(const e in p){if(!p.hasOwnProperty(e))continue;const o=p[e].request;if(o&&!r){const e=o(i,n,t.api,t.args);if(void 0!==e)try{r={scope:f,type:\"response\",id:t.id,api:t.api,result:await e}}catch(e){r={scope:f,type:\"response\",id:t.id,api:t.api,error:String(e)}}}}r||(r={scope:f,type:\"response\",id:t.id,api:t.api,error:\"Not supported\"}),i.postMessage(r,n)}else if(function(e){return b(e)&&\"response\"===e.type}(t)){const e=d[t.id];e&&e(t)}}function b(e){return!!e&&e.scope===f}function m(){return l++}const v={},M=[];let S;const k=new Promise((e=>{S=()=>{S=()=>{},e()}}));let O;function P(e,n,r=1e4){async function u(e,n){const t=await g(e,n,\".connect_api_client_v1\",[],0);if(t&&\"object\"==typeof t){return R(t,((t,i,o)=>{if(\".api_function_v1\"===i){const i=o?o+\".\"+String(t):String(t);return(...t)=>g(e,n,i,t,r)}return i}))}throw new Error(\"Failed to connect\")}function f(e){if(!e)return\"*\";try{return new URL(e).origin}catch(e){return\"*\"}}if(n&&(O=w({event:(e,t,i,r)=>n(i,r)})),e===window){if(0!==Object.keys(v).length)return Promise.resolve(v);if(s())return new Promise((async e=>{const n=await a();e(await u(n,\"*\"))}));if(o()){return u(c(),\"*\")}if(function(){const e=window;return e&&e.webkit&&e.webkit.messageHandlers&&e.webkit.messageHandlers.webwindowinterop}()){return u(t,\"*\")}if(function(){const e=window;return e&&e.hybridWebViewHost}()){return u(i,\"*\")}return Promise.resolve(v)}if((d=e)&&\"function\"==typeof d.postMessage)return u(e,\"*\");if((e=>e&&\"object\"==typeof e.contentWindow)(e)){const n=[];return n.push(new Promise(((n,t)=>{const i=async()=>{e.removeEventListener(\"load\",i),e.contentWindow?n(await u(e.contentWindow,f(e.src))):t(new Error(\"Cannot access the target content window\"))};e.addEventListener(\"load\",i)}))),e.contentWindow&&n.push(u(e.contentWindow,f(e.src))),Promise.race(n)}return Promise.reject(new Error(\"Target must be a window or an iframe\"));var d}function _(e){if(\"object\"!=typeof e)throw new Error(\"Api must be an object\");C(v,e),S()}function j(e){const n=M.find((n=>n.dispatcher===e.dispatcher));if(n)return n.identifier=e.identifier||n.identifier,n.origin=e.origin||n.origin,n;if(e.dispatcher){if(e.identifier){if(M.find((n=>n.identifier===e.identifier)))throw new Error(`[Workspace API] Client with identifier '${e.identifier}' already registered!`)}else e.identifier=r();return M.push(e),e}}function V(e){const n=M.findIndex((n=>n.dispatcher===e.dispatcher));-1!==n&&M.splice(n,1)}const E=(e,n,t,i)=>{if(t.origin){let r;r=t.identifier&&i&&t.identifier===i?Object.assign(Object.assign({},n),{origin:{isSelf:!0}}):n,h(t.dispatcher,t.origin,e,r)}};function H(e,n,t,i){if(t&&t.identifier){const r=M.find((e=>e.identifier===t.identifier));r&&E(e,n,r,i)}else for(const t of M)E(e,n,t,i)}function T(){try{return window.self!==window.top||s()||o()}catch(e){return!0}}function W(e,n){return\"function\"==typeof e&&\"function\"==typeof n&&e.name===n.name||(\"string\"==typeof e&&\"string\"==typeof n||\"number\"==typeof e&&\"number\"==typeof n)}function C(e,n){for(const t in n){const i=n[t];if(i)if(t in e){const n=e[t];if(\"object\"==typeof i&&\"object\"==typeof n)C(n,i);else{if(!W(i,n))throw new Error(`Cannot merge ${t} (${n} and ${i})`);e[t]=i}}else switch(typeof i){case\"object\":{const n={};C(n,i),e[t]=n;break}default:e[t]=i}}}function R(e,n,t){const i={};for(const r in e){const o=e[r];if((void 0!==t||\"onConnect\"!==r&&\"onRequest\"!==r)&&o)if(\"object\"==typeof o){const e=t&&t+\".\"+String(r)||String(r);i[r]=R(o,n,e)}else i[r]=n(r,e[r],t)}return i}var A,L,q,D;w({request:(e,n,t,i)=>{if(\".connect_api_client_v1\"===t)return k.then((()=>{let t=M.find((n=>n.dispatcher===e));if(t)t.origin=n;else{if(!e)return;t={dispatcher:e,origin:n,identifier:r()},M.push(t)}var i;(i=v)&&\"function\"==typeof i.onConnect&&v.onConnect(t);return R(v,((e,n)=>\"function\"==typeof n?\".api_function_v1\":n))}));{const r=M.find((t=>t.dispatcher===e&&t.origin===n));if(r){if((o=v)&&\"function\"==typeof o.onRequest){const e=v.onRequest(r,t,i);if(void 0!==e)return e}const e=function(e,n){const t=n.split(\".\");let i=e;for(const e of t)i=\"object\"==typeof i&&i&&e in i?i[e]:void 0;return i}(v,t);if(\"function\"==typeof e){const n=e.apply(void 0,i);return void 0===n?Promise.resolve(n):n}return Promise.resolve(e)}return}var o}}),function(e){e[e.LengthMeasure=0]=\"LengthMeasure\",e[e.AreaMeasure=1]=\"AreaMeasure\",e[e.VolumeMeasure=2]=\"VolumeMeasure\",e[e.MassMeasure=3]=\"MassMeasure\",e[e.AngleMeasure=4]=\"AngleMeasure\",e[e.StringValue=5]=\"StringValue\",e[e.IntValue=6]=\"IntValue\",e[e.DoubleValue=7]=\"DoubleValue\",e[e.DateTime=8]=\"DateTime\",e[e.Logical=9]=\"Logical\",e[e.Boolean=10]=\"Boolean\"}(A||(A={})),function(e){e[e.Selected=1]=\"Selected\",e[e.Hidden=4]=\"Hidden\",e[e.SelectedHidden=5]=\"SelectedHidden\",e[e.Visible=6]=\"Visible\",e[e.SelectedVisible=7]=\"SelectedVisible\",e[e.Highlighted=8]=\"Highlighted\"}(L||(L={})),function(e){e.Project=\"project\",e.Viewer=\"3dviewer\"}(q||(q={})),function(e){e.Models=\"models\",e.Layers=\"layers\",e.Attachments=\"attachments\",e.ToDos=\"todos\",e.Views=\"views\",e.ClashSets=\"clashes\",e.Organizer=\"organizer\",e.DataTable=\"contentbrowser\",e.Topics=\"topics\",e.LiveCollaboration=\"livecollaboration\",e.StatusSharing=\"statussharing\",e.Connect2Fab=\"connect2fab\",e.QrMarkers=\"qrmarkers\",e.RealityCapture=\"realitycapture\"}(D||(D={}));const N=[\"reset\",\"selection\",\"areaSelection\",\"measurement\",\"pointMarkup\",\"cloudMarkup\",\"arrowMarkup\",\"lineMarkup\",\"textMarkup\",\"freelineMarkup\",\"clipPlane\",\"verticalClipPlane\",\"picking\"],I=[\"edge\",\"point\",\"surface\"];var U,$,x;function B(e,n,t){return window.removeEventListener(\"message\",G),window.addEventListener(\"message\",G),O&&O(),P(e,n,t)}function z(e){return _(e)}function F(e,n,t,i){h(e,n,t,i)}function G(e){return y(e)}function J(e=\"prod\"){return`https://${{int:\"web.int\",qa:\"web.qa\",stage:\"web.stage\",prod:\"web\"}[e]}.connect.trimble.com?isEmbedded=true`}!function(e){e.LookAround=\"look_around\",e.Pan=\"pan\",e.Panorama=\"panorama\",e.Rotate=\"rotate\",e.Walk=\"walk\"}(U||(U={})),function(e){e[e.Guid=0]=\"Guid\",e[e.String=1]=\"String\",e[e.SpatialHash=2]=\"SpatialHash\",e[e.DwgHandle=3]=\"DwgHandle\",e[e.None=4]=\"None\"}($||($={})),function(e){e[e.SORT_NONE=0]=\"SORT_NONE\",e[e.SORT_UP=1]=\"SORT_UP\",e[e.SORT_DOWN=-1]=\"SORT_DOWN\"}(x||(x={}));export{U as CameraMode,q as ExtensionType,$ as IdentifierType,A as PropertyType,x as SortDirection,N as TOOLS,I as TOOL_SNAP_TYPES,D as TabPanelId,L as ViewEntityStates,B as connect,G as dispatcherEventListener,z as expose,J as getConnectEmbedUrl,T as isApplicationEmbedded,j as preregister,V as removeClient,F as sendEvent,H as sendEventToAllClients};\n","/* * This file is part of the Trimble Connect Workspace API.\n * It provides functions to interact with the Trimble Connect API, specifically for user and project management.\n * \n * @license Apache-2.0\n * \n * The code is intended to be used in a browser environment and requires the Trimble Connect Workspace API to be loaded.\n */\nimport { formatHref } from \"./auth\";\nimport { delayed } from  \"./detailTask\";\nimport { errorConsole } from \"./errorConsole\";\n\n/* * Base URL for the Trimble Connect API.\n * This should be set to the appropriate environment variable or default value.\n * It is used to construct the full API endpoint URLs.\n */\nconst TC_BASE_URL = process.env.TC_BASE_URL ;\n\n/* * ユーザー情報を取得する関数。\n * @returns {Promise<Object>} ユーザー情報を含むPromiseオブジェクト。\n */\nexport async function getUsersMe() {\n    if(window.session==undefined) return false;\n\n    const res = await fetch(formatHref(`${TC_BASE_URL}/tc/api/2.0`, \"/users/me\"), {\n        cache: \"default\",\n        headers: new Headers({\n            \"Content-Type\" : \"application/json\",\n            Authorization  : `Bearer ${window.session.accessToken}`\n        }),\n        method: \"GET\",\n    });\n    if (!res.ok) {\n        return errorConsole(res);\n    }\n    if(res.status == 202){\n        const task = (await res.json());\n        return await delayed(task);\n    }\n    return(await res.json());\n}\n\n/* * プロジェクトの一覧を取得する関数。\n * @param {boolean} fullLoaded - 完全に読み込むかどうかのフラグ。\n * @returns {Promise<Array>} プロジェクトの配列を含むPromiseオブジェクト。\n */\nexport async function getProjects(){\n    const res = await fetch(formatHref(`${TC_BASE_URL}/tc/api/2.0`, \"/projects\", {fullyLoaded : \"true\"}), {\n        cache: \"default\",\n        headers: new Headers({\n            \"Content-Type\" : \"application/json\",\n            Authorization  : `Bearer ${window.session.accessToken}`\n        }),\n        method: \"GET\",\n    });\n    if (!res.ok) {\n        return errorConsole(res);\n    }\n    if(res.status == 202){\n        const task = (await res.json());\n        return await delayed(task);\n    }\n    return(await res.json());\n}","/**\n * Returns the formatted date.\n * @param utcDateAndTime The UTC timestamp as a string.\n */\n\nconst TC_CLIENT_ID    = process.env.TC_CLIENT_ID ;\nconst TC_CLIENT_APP   = process.env.TC_CLIENT_APP ; \nconst TC_REDIRECT_URI = process.env.TC_REDIRECT_URI ;\nconst TC_CLIENT_KEY   = process.env.TC_CLIENT_KEY ;\n\n/** Returns the current UTC timestamp in seconds. */\nfunction utcTimestamp() {\n    return Math.floor(new Date().getTime() / 1000);\n}\n\nconst loggers = {};\ncreateLogger(\"sok_works\");\n\n/* istanbul ignore next */\nfunction createLogger(name) {\n    if (loggers[name]) {\n        return loggers[name];\n    }\n    /* istanbul ignore next */\n    const api = {};\n    const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n    };\n    /* istanbul ignore next */\n    const print = (method, ...msg) => {\n        const styles = [\n            `border: 1px solid ${methodToColorMap[method]}`,\n            `border-radius: 0.5em`,\n            `color: ${methodToColorMap[method]}`,\n            `font-weight: bold`,\n            `padding: 2px 0.5em`,\n        ];\n        const logPrefix = [`%c${name}`, styles.join(\";\")];\n        console[method](...logPrefix, ...msg);\n    };\n    for (const method of Object.keys(methodToColorMap)) {\n        api[method] = (...msg) => print(method, ...msg);\n    }\n    loggers[name] = api;\n    return api;\n}\n\n/**\n * Returns a boolean indicating whether the value is null or undefined.\n * @param value The value.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n\n/**\n * Returns a formatted HREF.\n * @param baseUri The base URI.\n * @param path The path, including the leading slash.\n * @param query An object containing the query key-value pairs.\n */\nexport function formatHref(baseUri, path, query) {\n    let result = baseUri;\n    /* istanbul ignore else */\n    if (path) {\n        result += path;\n    }\n    /* istanbul ignore else */\n    if (query) {\n        result += \"?\" + formatQueryParameters(query);\n    }\n    return result;\n}\n/**\n * Returns formatted query parameters.\n * @param query An object containing the query key-value pairs.\n */\nfunction formatQueryParameters(query) {\n    const params = [];\n    for (const key in query) {\n        /* istanbul ignore else */\n        if (query.hasOwnProperty(key)) {\n            const value = query[key];\n            /* istanbul ignore else */\n            if (!isNullOrUndefined(value)) {\n                params.push(`${key}=${encodeURIComponent(String(value))}`);\n            }\n        }\n    }\n    return params.join(\"&\");\n}\n/**\n * Returns a parsed query parameter or undefined if the HREF cound not be parsed.\n * @param hrefText The HREF to parse.\n * @param name The parameter name.\n */\nfunction parseQueryParameter(href, name) {\n    const regex = new RegExp(\"[?&]\" + name.replace(/[\\[\\]]/g, \"\\\\$&\") + \"(=([^&#]*)|&|#|$)\");\n    const results = regex.exec(href);\n    if (!results) {\n        return undefined;\n    }\n    else if (results[2] === undefined) {\n        return null;\n    }\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n/**\n * Returns true if the URL's host points to staging environment or 'env=stage' query parameter was explicitly used.\n * @param url The full URL to parse.\n */\nconst isStageEnv = (url) => {\n    const compareStage = (value) => (value ?? \"\").toLowerCase() === \"stage\";\n    const _url = new URL(url);\n    const host_split = _url.host.split(\".\");\n    if (host_split.length >= 2 && compareStage(host_split[1])) {\n        return true;\n    }\n    return compareStage(parseQueryParameter(_url.href, \"env\"));\n};\n\n/**\n * Returns the claims from a JSON Web Token without verification.\n * @param token The token to parse.\n */\nfunction parseJwt(token) {\n    function decodeBase64(base64) {\n        base64 = base64.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        switch (base64.length % 4) {\n            case 0:\n                break;\n            case 2:\n                base64 += \"==\";\n                break;\n            case 3:\n                base64 += \"=\";\n                break;\n            default:\n                throw new Error(\"Invalid token encoding.\");\n        }\n        return decodeURIComponent(atob(base64)\n            .split(\"\")\n            .map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2))\n            .join(\"\"));\n    }\n    return JSON.parse(decodeBase64(token.split(\".\")[1]));\n}\n\n/**\n * Removes all properties from an object and returns it.\n * @param obj The object.\n */\nfunction clear(obj) {\n    Object.keys(obj).forEach((key) => delete obj[key]);\n    return obj;\n}\n\n// Promise that indicates whether an API has been exposed.\nnew Promise((resolve) => {\n});\n\n/** EmulatedStorage is a simple Map emulating Storage.\n *  Used in cases where actual browers local/session storage can't be used.\n * */\nclass EmulatedStorage {\n    constructor() {\n        this.storage = new Map();\n    }\n    get length() {\n        return this.storage.size;\n    }\n    getItem(key) {\n        const item = this.storage.get(key);\n        return item === undefined ? null : item;\n    }\n    setItem(key, value) {\n        this.storage.set(key, value);\n        if (this.itemInsertionCallback) {\n            this.itemInsertionCallback(this.length);\n        }\n    }\n    removeItem(key) {\n        this.storage.delete(key);\n    }\n    clear() {\n        return this.storage.clear();\n    }\n    key(index) {\n        const keys = [];\n        for (const k of this.storage.keys()) {\n            keys.push(k);\n        }\n        return keys[index];\n    }\n}\n/** Uses native localStorage or sessionStorage if available.\n * Otherwise in-memory storage is used.\n * If in-memory object already exists in window, that one is used. Otherwise new one is created. */\nclass AppStorage {\n    constructor(storageType) {\n        this.storageType = storageType;\n        this._underlyingStorage = this.getStorage();\n    }\n    getStorage() {\n        let storage;\n        try {\n            /** No window when executing in node */\n            /* istanbul ignore next */\n            storage = typeof window === \"undefined\" ? global[this.storageType] : window[this.storageType];\n            const x = \"__storage_test__\";\n            storage.setItem(x, x);\n            storage.removeItem(x);\n            return storage;\n        }\n        catch (e) {\n            if (\n            // everything except Firefox\n            (e.code === 22 ||\n                // Firefox\n                e.code === 1014 ||\n                // test name field too, because code might not be present\n                // everything except Firefox\n                e.name === \"QuotaExceededError\" ||\n                // Firefox\n                e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\n                // acknowledge QuotaExceededError only if there's something already stored\n                storage &&\n                storage.length !== 0) {\n                throw e;\n            }\n            else {\n                /** No window when executing in node */\n                /* istanbul ignore next */\n                const parent = typeof window === \"undefined\" ? global : window;\n                const storageProperty = `emulated${this.storageType}`;\n                if (!parent.hasOwnProperty(storageProperty)) {\n                    parent[storageProperty] = new EmulatedStorage();\n                }\n                return parent[storageProperty];\n            }\n        }\n    }\n    /** Get underlying native or emulated storage. Used in tests. */\n    get underlyingStorage() {\n        return this._underlyingStorage;\n    }\n    /** Reload the storage. Used in tests. */\n    reload() {\n        this._underlyingStorage = this.getStorage();\n    }\n    get length() {\n        return this._underlyingStorage.length;\n    }\n    getItem(key) {\n        return this._underlyingStorage.getItem(key);\n    }\n    setItem(key, value) {\n        return this._underlyingStorage.setItem(key, value);\n    }\n    removeItem(key) {\n        return this._underlyingStorage.removeItem(key);\n    }\n    clear() {\n        return this._underlyingStorage.clear();\n    }\n    key(index) {\n        return this._underlyingStorage.key(index);\n    }\n}\nconst LocalStorage = new AppStorage(\"localStorage\");\nnew AppStorage(\"sessionStorage\");\n\n/* tslint:disable no-bitwise */\nvar NumberFormat;\n(function (NumberFormat) {\n    NumberFormat[NumberFormat[\"AllowNegative\"] = 1] = \"AllowNegative\";\n    NumberFormat[NumberFormat[\"AllowIntegers\"] = 2] = \"AllowIntegers\";\n    NumberFormat[NumberFormat[\"AllowDecimals\"] = 4] = \"AllowDecimals\";\n    NumberFormat[NumberFormat[\"AllowScientific\"] = 8] = \"AllowScientific\";\n    NumberFormat[NumberFormat[\"AllowFractions\"] = 16] = \"AllowFractions\";\n    NumberFormat[NumberFormat[\"Any\"] = 31] = \"Any\";\n})(NumberFormat || (NumberFormat = {}));\n\nvar FeetInchesType;\n(function (FeetInchesType) {\n    FeetInchesType[FeetInchesType[\"Feet\"] = 0] = \"Feet\";\n    FeetInchesType[FeetInchesType[\"Inches\"] = 1] = \"Inches\";\n    FeetInchesType[FeetInchesType[\"FeetInches\"] = 2] = \"FeetInches\";\n})(FeetInchesType || (FeetInchesType = {}));\n\nconst SESSION_KEY = isStageEnv(window.location.href) ? \"trimble-services-stage\" : \"trimble-services\";\nconst currentSession = initSession();\nconst config = {\n    connectProvider: \"\",\n    identityClientApp: \"\",\n    identityClientId: \"\",\n    identityClientKey: \"\",\n    identityProvider: \"\",\n    identityRedirectUri: \"\",\n};\n/**\n * Configures the identity provider. You MUST call this before using any other function from this module.\n * @param configuration The configuration.\n */\nfunction configure(configuration) {\n    if (!isValidConfiguration(configuration)) {\n        throw new Error(\"Invalid configuration.\");\n    }\n    Object.assign(config, configuration);\n    if (config.authGrants) {\n        saveSession(convertToSession(config.authGrants));\n    }\n}\n/**\n * Begins or resumes a session. Returns redirect URI if session cannot be acquired.\n */\nasync function signIn(configuration) {\n    if (configuration) {\n        configure(configuration);\n    }\n    ensureConfigured();\n    const code = parseQueryParameter(window.location.href, \"code\");\n    if (code) {\n        try {\n            saveSession(await requestSession(code), true);\n            return Promise.resolve({ uri: parseQueryParameter(window.location.href, \"state\") || config.identityRedirectUri });\n        }\n        catch (error) {\n            clearSession();\n        }\n    }\n    return getSession();\n}\n/**\n * Saves the session data to the local storage.\n * @param session The session.\n * @param replace True to replace the session, false to update.\n */\nfunction saveSession(session, replace) {\n    if (replace) {\n        Object.assign(clear(currentSession), session);\n    }\n    else {\n        Object.assign(currentSession, session);\n    }\n    getSessionStorage().setItem(SESSION_KEY, JSON.stringify(currentSession));\n    return currentSession;\n}\n// --------------------------------------------------------------------------------\nfunction getSessionStorage() {\n    return window.__TRIMBLE_ServiceSessionStorage__ || LocalStorage;\n}\nfunction isValidConfiguration(configuration) {\n    return Boolean(configuration.identityRedirectUri &&\n        configuration.identityProvider &&\n        configuration.identityClientApp &&\n        configuration.identityClientId &&\n        configuration.identityClientKey);\n}\nfunction convertToSession(grants) {\n    function convertToUser(data) {\n        const user = {};\n        for (const key in data) {\n            user[key] = data[key];\n        }\n        return user;\n    }\n    const claims = grants.id_token ? parseJwt(grants.id_token) : undefined;\n    return {\n        expiresAt: (claims && claims.exp) || utcTimestamp() + 3600,\n        refreshToken: grants.refresh_token,\n        sessionToken: grants.id_token,\n        accessToken: grants.access_token,\n        user: claims && convertToUser(claims),\n    };\n}\nfunction ensureConfigured() {\n    if (!isValidConfiguration(config)) {\n        throw new Error(\"Invalid configuration. Did you forget to call configure()?\");\n    }\n}\n/**\n * Returns the current session or redirect URI if redirect is required.\n * @param refresh Indicates whether to force session refresh.\n */\nasync function getSession(refresh = false) {\n    ensureConfigured();\n    // Refresh is not requested and the session is valid.\n    if (!refresh && isValidSession(currentSession)) {\n        return currentSession;\n    }\n    // Refresh is requested and the session issuer is valid.\n    if (isValidSessionIssuer(currentSession) && canRefresh(currentSession)) {\n        try {\n            return saveSession(await refreshSession(currentSession), true);\n        }\n        catch (error) {\n            clearSession();\n        }\n    }\n    return Promise.resolve({ uri: getSignInHref() });\n}\n/**\n * Session is valid if there is an access token which is not yet expired. Session (id_token) and refresh tokens are optional.\n */\nfunction isValidSession(session) {\n    return Boolean(session && session.accessToken && session.expiresAt && session.expiresAt > utcTimestamp()) && isValidSessionIssuer(session);\n}\n/**\n * Session issuer is valid if there is no session token or if the session token issuer is the same with the configured identity provider.\n */\nfunction isValidSessionIssuer(session) {\n    return (!session?.sessionToken ||\n        (!!session && (!config || !config.identityProvider || !session.user || !session.user.iss || session.user.iss === config.identityProvider)));\n}\nfunction initSession() {\n    const session = getSessionStorage().getItem(SESSION_KEY);\n    if (session) {\n        return JSON.parse(session);\n    }\n    else {\n        return {};\n    }\n}\nfunction clearSession() {\n    getSessionStorage().removeItem(SESSION_KEY);\n}\nfunction canRefresh(session) {\n    return Boolean(session && session.sessionToken && session.refreshToken);\n}\nasync function requestSession(code) {\n    const res = await fetch(formatHref(config.identityProvider, \"/oauth/token\"), {\n        body: formatQueryParameters({\n            code,\n            grant_type: \"authorization_code\",\n            redirect_uri: config.identityRedirectUri,\n            tenantDomain: \"trimble.com\",\n        }),\n        cache: \"default\",\n        headers: new Headers({\n            Accept: \"application/json\",\n            Authorization: `Basic ${btoa(config.identityClientId + \":\" + config.identityClientKey)}`,\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }),\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        throw new Error(res.statusText);\n    }\n    const grants = (await res.json());\n    if (!grants.id_token) {\n        throw new Error(\"Unauthorized\");\n    }\n    return convertToSession(grants);\n}\nasync function refreshSession(session) {\n    const res = await fetch(formatHref(config.identityProvider, \"/oauth/token\"), {\n        body: formatQueryParameters({\n            grant_type: \"refresh_token\",\n            refresh_token: session.refreshToken,\n            tenantDomain: \"trimble.com\",\n        }),\n        cache: \"default\",\n        headers: new Headers({\n            Accept: \"application/json\",\n            Authorization: `Basic ${btoa(config.identityClientId + \":\" + config.identityClientKey)}`,\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }),\n        method: \"POST\",\n    });\n    if (!res.ok) {\n        throw new Error(res.statusText);\n    }\n    const grants = (await res.json());\n    if (!grants.id_token) {\n        throw new Error(\"Unauthorized\");\n    }\n    return convertToSession(grants);\n}\nfunction getSignInHref(states) {\n    /** identity provider for federated workflow (eg: hitachi, okta_trimble) */\n    const federatedIdentityProvider = parseQueryParameter(window.location.href, \"identity_provider\");\n    const returnUri = window.location.href.replace(/(?:code|sessionDataKey)(?:=[^&]*)?&?/g, \"\");\n    let stateUrl = returnUri;\n    if (states) {\n        const url = parseURL(returnUri);\n        if (url) {\n            const keys = Object.keys(states);\n            keys.forEach((k) => url.searchParams.append(k, states[k]));\n            stateUrl = url.href;\n        }\n    }\n    if (stateUrl === config.identityRedirectUri) {\n        stateUrl = undefined;\n    }\n    return formatHref(config.identityProvider, \"/oauth/authorize\", {\n        client_id: config.identityClientId,\n        redirect_uri: getRedirectUrl(),\n        response_type: \"code\",\n        scope: \"openid \" + config.identityClientApp,\n        state: stateUrl,\n        identity_provider: federatedIdentityProvider,\n    });\n}\nfunction getRedirectUrl() {\n    return config.identityRedirectUri;\n}\nfunction parseURL(url) {\n    try {\n        return new URL(url);\n    }\n    catch {\n        return undefined;\n    }\n}\n\nasync function login() {\n    /*\n    const result = await signIn({\n        identityRedirectUri: \"http://localhost:8080/login/oauth2/code/trimble-connect\",\n        identityClientApp: \"sok-local\",\n        identityClientId: \"0d32eee4-9112-49c7-85c6-9bd02f8187ea\",\n        identityClientKey: \"d4b32da5bcee4af29191b7c8678dc0a5\",\n        connectProvider: \"//app.connect.trimble.com\",\n        identityProvider: \"https://id.trimble.com\"\n    });\n    */\n    const result = await signIn({\n        identityRedirectUri: process.env.TC_REDIRECT_URI,\n        identityClientApp: \"sok-local\",\n        identityClientId: process.env.TC_CLIENT_ID,\n        identityClientKey: process.env.TC_CLIENT_KEY,\n        connectProvider: \"//app.connect.trimble.com\",\n        identityProvider: \"https://id.trimble.com\"\n    });\n    \n    if (result.accessToken){\n        return result;\n    }\n    window.location.href = result.uri;\n}\n\nasync function logout(token){\n    var url = `https://id.trimble.com/oauth/logout?id_token_hint=${token}` ;\n    window.location.href = url ;\n}\n\nexport { login, logout }\n","import { formatHref } from \"./auth\";\nimport { errorConsole } from \"./errorConsole\";\n\n/**\n * 遅延機構からレスポンスを回収する\n * @param {*} taskid \n * @returns \n */\nasync function delayedTask(taskid){\n    if(window.session==undefined) return false;\n\n    const res = await fetch(formatHref(window.baseUrl, `/delayedTask/${taskid}`), {\n        cache: \"default\",\n        headers: new Headers({\n            \"Content-Type\" : \"application/json\",\n            Authorization  : `Bearer ${window.session.accessToken}`\n        }),\n        method: \"GET\",\n    });\n    if(!res.ok) {\n        return errorConsole(res) ;\n    }\n    return (await res.json());\n}\n\n/**\n * 遅延機構の呼び出し\n * @param {*} taskid \n * @returns \n */\nexport async function delayed(task){\n    var loop = true ;\n    var result = undefined ;\n\n    //**タイムアウトをセット 1分*/\n    let h = setTimeout(function(){\n        loop = false ;\n        console.log(`${task.requestType} : タイムアウト`);\n    }, 60000 * 1 );\n\n    do {\n        let data = await delayedTask(task.taskID) ;\n        if(data.status != 0 ){\n            loop = false;\n            if(data.status == 1){\n                result = atob(data.resultInformation);\n            }\n        }\n    } while (loop) ;\n    clearTimeout(h);\n\n    if(result != undefined ) return JSON.parse(result);\n    \n    return undefined;\n}\n","export async function errorConsole(res){\n    if(res.status == 500){\n        const err = (await res.json());\n        console.error(`error code : ${err.errorCode} - ${err.errorMessage}`)\n    }else{\n        console.error(`response code : ${res.status} - ${res.statusText}`)\n    }\n    console.error(`url : ${res.url}`)\n    return undefined;\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n  * @file main.js \n  *  This file is the entry point for the application.\n  *  It initializes the application and handles user authentication.\n  *  It is designed to work with a specific API and handles login functionality.\n  *  The application is intended to run in a browser environment.\n  */\n\nimport {connect} from \"trimble-connect-workspace-api\"\n\nconst url = new URL(location.href);\nif ((url.host === \"localhost:8080\" || url.search.includes(\"login\")) && !url.search.includes(\"nologin\")) { //デバッグ中\n    document.querySelector(\"html\").style.display = \"none\";\n    (async () => {\n        const auth = require(\"./api/auth\");\n        window.session = await auth.login();\n        if (window.session) {\n            document.querySelector(\"html\").style.removeProperty(\"display\");\n            inistializeApp();\n        }\n    })();\n}\n\nasync function inistializeApp() {\n    const api = require(\"./api/api\");\n\n    // Get the authentication token from the session\n    const token = window.session.accessToken;\n\n    // Fetch user information\n    await api.getUsersMe(token).then(user => {\n        console.log(\"User Info:\", user);\n    }).catch(error => {\n        console.error(\"Error fetching user info:\", error);\n    });\n\n    // Fetch projects\n    await api.getProjects().then(projects => {\n        console.log(\"Projects:\", projects);\n    }).catch(error => {\n        console.error(\"Error fetching projects:\", error);\n    });\n}\n"],"names":[],"sourceRoot":""}